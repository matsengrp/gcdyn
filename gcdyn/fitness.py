r"""Uses phenotype to determine fitness of B cells in the germinal center light zone"""
from __future__ import annotations
from typing import Callable
from math import exp
import pandas as pd


class Fitness:
    r"""Class to determine fitness from phenotype for a collection of sequences

    Args:
        tfh_function: method to map from KD to T cell help, taking in a DataFrame with a ``KD`` column and producing a DataFrame with a ``t_cell_help`` column
        concentration_antigen: molar concentration of antigen to determine antigen bound
    """

    def __init__(
        self,
        tfh_function: Callable[..., pd.DataFrame],
        concentration_antigen: float = 10 ** (-9),
    ):
        self.tfh_function = tfh_function
        self.concentration_antigen = concentration_antigen

    def frac_antigen_bound(self, sequence_KDs: list[float]) -> list[float]:
        r"""Determine the fraction of antigen bound from a list of KD values using the Hill equation.

        Args:
            sequence_KDs: list of KDs that will each be used to determine the fraction of antigen bound.

        Returns:
            thetas: list of values representing the fraction of receptors with antigen bound
        """
        thetas = []
        for seq_KD in sequence_KDs:
            # Hill equation with n = 1:
            theta = self.concentration_antigen / (seq_KD + self.concentration_antigen)
            thetas.append(theta)
        return thetas

    def linear_fitness(
        self, seq_df: pd.DataFrame, y_intercept: float = 0, slope: float = 1
    ) -> pd.DataFrame:
        r"""Combines methods to get the antigen bound and T cell help
        from the KD using a linear model.

        Args:
            seq_df: DataFrame with KD column
            y_intercept: amount of T-cell help with no antigen bound
            slope: slope of model

        Returns:
            seq_df: DataFrame with KD column, frac_antigen_bound column, and fitness (T-cell help) column
        """
        seq_df["frac_antigen_bound"] = self.frac_antigen_bound(seq_df["KD"])
        seq_df["t_cell_help"] = seq_df["frac_antigen_bound"] * slope
        return seq_df

    def sigmoidal_fitness(
        self,
        seq_df: pd.DataFrame,
        maximum_Tfh: float = 4,
        curve_steepness: float = 10,
        midpoint_antigen_bound: float = 0.5,
    ) -> pd.DataFrame:
        r"""Combines methods to get the antigen bound and T cell help
        from the KD using a sigmoidal model.

        Args:
            seq_df:
            maximum_Tfh: maximum possible T cell help generated by model
            curve_steepness: logistic growth rate of T cell help
            midpoint_antigen_bound: value of input antigen bound to set as midpoint

        Returns:
            seq_df: DataFrame of results
        """
        seq_df["frac_antigen_bound"] = self.frac_antigen_bound(seq_df["KD"])
        for idx, row in seq_df.iterrows():
            antigen_bound = row.frac_antigen_bound
            t_cell_help = maximum_Tfh / (
                1 + exp(-1 * curve_steepness * (antigen_bound - midpoint_antigen_bound))
            )
            seq_df.loc[idx, "t_cell_help"] = t_cell_help
        return seq_df

    def fitness_df(
        self,
        seq_list: list[str] = None,
        calculate_KD: Callable[list[str], list[float]] = None,
    ) -> pd.DataFrame:
        r"""Produces a dataframe including the fitness of a series of sequences given KD values.

        Args:
            seq_list: list of DNA sequences
            calculate_KD: method that produces a KD value for each sequence in the list

        Returns:
            DataFrame with columns ``frac_antigen_bound``, ``KD``, ``t_cell_help``, and ``normalized_t_cell_help``
            with t_cell_help values based on ``tfh_function`` set on initialization
        """
        KD_values = calculate_KD(seq_list)
        seq_df = pd.DataFrame({"seq": seq_list, "KD": KD_values})
        seq_df = self.tfh_function(self, seq_df=seq_df)
        sum_fitness = seq_df["t_cell_help"].sum()
        seq_df["normalized_t_cell_help"] = (seq_df["t_cell_help"]) / (sum_fitness)
        return seq_df

    def map_cell_divisions(
        self, seq_df: pd.DataFrame, slope: float = 1, y_intercept: float = 0
    ) -> list[float]:
        """Map T cell help linearly to the number of cell divisions using
        slope.

        Args:
            seq_df: ``DataFrame`` with column ``normalized_t_cell_help``
            slope: slope of normalized T cell help vs cell divisions
            y_intercept: cell divisions with no T cell help

        Returns:
            cell_divisions: list of cell division counts for each sequence
        """
        seq_df["cell_divisions"] = (
            seq_df["normalized_t_cell_help"] * slope
        ) + y_intercept
        return seq_df["cell_divisions"]

    def map_cell_divisions_sigmoidal(
        self,
        seq_df: pd.DataFrame,
        maximum_cell_divisions: float = 6,
        curve_steepness: float = 10,
        midpoint_fitness: float = 0.5,
    ) -> list[float]:
        """Map normalized T cell help to the number of cell divisions using a
        sigmoidal transformation.

        Args:
            seq_df: ``DataFrame`` with column ``normalized_t_cell_help``
            maximum_cell_divisions: maximum producable number of cell divisions
            curve_steepness: logistic growth rate
            midpoint_fitness: value of T cell help to set as midpoint

        Returns:
            cell_divisions: list of cell division counts for each sequence
        """
        for idx, row in seq_df.iterrows():
            normalized_t_cell_help = row.normalized_t_cell_help
            cell_divs = maximum_cell_divisions / (
                1
                + exp(
                    -1 * curve_steepness * (normalized_t_cell_help - midpoint_fitness)
                )
            )
            seq_df.loc[idx, "cell_divisions"] = cell_divs
        return seq_df["cell_divisions"]
