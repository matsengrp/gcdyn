<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ete3.coretype.tree &mdash; gcdyn  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> gcdyn
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing <code class="docutils literal notranslate"><span class="pre">gcdyn</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">Modules</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developer.html">Open source code repository</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer.html#developer-tools">Developer tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developer.html#todo-list">Todo list</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gcdyn</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ete3.coretype.tree</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ete3.coretype.tree</h1><div class="highlight"><pre>
<span></span><span class="c1"># #START_LICENSE###########################################################</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># This file is part of the Environment for Tree Exploration program</span>
<span class="c1"># (ETE).  http://etetoolkit.org</span>
<span class="c1">#</span>
<span class="c1"># ETE is free software: you can redistribute it and/or modify it</span>
<span class="c1"># under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># ETE is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1"># ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="c1"># or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public</span>
<span class="c1"># License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with ETE.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#                     ABOUT THE ETE PACKAGE</span>
<span class="c1">#                     =====================</span>
<span class="c1">#</span>
<span class="c1"># ETE is distributed under the GPL copyleft license (2008-2015).</span>
<span class="c1">#</span>
<span class="c1"># If you make use of ETE in published work, please cite:</span>
<span class="c1">#</span>
<span class="c1"># Jaime Huerta-Cepas, Joaquin Dopazo and Toni Gabaldon.</span>
<span class="c1"># ETE: a python Environment for Tree Exploration. Jaime BMC</span>
<span class="c1"># Bioinformatics 2010,:24doi:10.1186/1471-2105-11-24</span>
<span class="c1">#</span>
<span class="c1"># Note that extra references to the specific methods implemented in</span>
<span class="c1"># the toolkit may be available in the documentation.</span>
<span class="c1">#</span>
<span class="c1"># More info at http://etetoolkit.org. Contact: huerta@embl.de</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># #END_LICENSE#############################################################</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">md5</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cmp_to_key</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cPickle</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">zip</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">..parser.newick</span> <span class="kn">import</span> <span class="n">read_newick</span><span class="p">,</span> <span class="n">write_newick</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">utils</span>

<span class="c1"># the following imports are necessary to set fixed styles and faces</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">..treeview.main</span> <span class="kn">import</span> <span class="n">NodeStyle</span><span class="p">,</span> <span class="n">_FaceAreas</span><span class="p">,</span> <span class="n">FaceContainer</span><span class="p">,</span> <span class="n">FACE_POSITIONS</span>
    <span class="kn">from</span> <span class="nn">..treeview.faces</span> <span class="kn">import</span> <span class="n">Face</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">TREEVIEW</span> <span class="o">=</span> <span class="kc">False</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">TREEVIEW</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Tree&quot;</span><span class="p">,</span> <span class="s2">&quot;TreeNode&quot;</span><span class="p">]</span>

<span class="n">DEFAULT_COMPACT</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">DEFAULT_SHOWINTERNAL</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">DEFAULT_DIST</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">DEFAULT_SUPPORT</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">DEFAULT_NAME</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

<span class="k">class</span> <span class="nc">TreeError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A problem occurred during a TreeNode operation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TreeNode (Tree) class is used to store a tree structure. A tree</span>
<span class="sd">    consists of a collection of TreeNode instances connected in a</span>
<span class="sd">    hierarchical way. Trees can be loaded from the New Hampshire Newick</span>
<span class="sd">    format (newick).</span>

<span class="sd">    :argument newick: Path to the file containing the tree or, alternatively,</span>
<span class="sd">       the text string containing the same information.</span>

<span class="sd">    :argument 0 format: subnewick format</span>

<span class="sd">      .. table::</span>

<span class="sd">          ======  ==============================================</span>
<span class="sd">          FORMAT  DESCRIPTION</span>
<span class="sd">          ======  ==============================================</span>
<span class="sd">          0        flexible with support values</span>
<span class="sd">          1        flexible with internal node names</span>
<span class="sd">          2        all branches + leaf names + internal supports</span>
<span class="sd">          3        all branches + all names</span>
<span class="sd">          4        leaf branches + leaf names</span>
<span class="sd">          5        internal and leaf branches + leaf names</span>
<span class="sd">          6        internal branches + leaf names</span>
<span class="sd">          7        leaf branches + all names</span>
<span class="sd">          8        all names</span>
<span class="sd">          9        leaf names</span>
<span class="sd">          100      topology only</span>
<span class="sd">          ======  ==============================================</span>

<span class="sd">    :returns: a tree node object which represents the base of the tree.</span>

<span class="sd">    **Examples:**</span>

<span class="sd">    ::</span>

<span class="sd">        t1 = Tree() # creates an empty tree</span>
<span class="sd">        t2 = Tree(&#39;(A:1,(B:1,(C:1,D:1):0.5):0.5);&#39;)</span>
<span class="sd">        t3 = Tree(&#39;/home/user/myNewickFile.txt&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span>
    <span class="k">def</span> <span class="nf">_set_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s1">&#39;node dist must be a float number&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_support</span>
    <span class="k">def</span> <span class="nf">_set_support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_support</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s1">&#39;node support must be a float number&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_up</span>
    <span class="k">def</span> <span class="nf">_set_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_up</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;bad node_up type&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_children</span>
    <span class="k">def</span> <span class="nf">_set_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Incorrect child node type&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Incorrect children type&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_style</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_img_style</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_style</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_img_style</span>

    <span class="k">def</span> <span class="nf">_set_style</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_style</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="c1">#: Branch length distance to parent node. Default = 0.0</span>
    <span class="n">img_style</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_style</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_style</span><span class="p">)</span>

    <span class="c1">#: Branch length distance to parent node. Default = 0.0</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_dist</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_dist</span><span class="p">)</span>
    <span class="c1">#: Branch support for current node</span>
    <span class="n">support</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_support</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_support</span><span class="p">)</span>
    <span class="c1">#: Pointer to parent node</span>
    <span class="n">up</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_up</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_up</span><span class="p">)</span>
    <span class="c1">#: A list of children nodes</span>
    <span class="n">children</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_children</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_children</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_face_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_FaceAreas</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">] is not a valid FaceAreas instance&quot;</span> <span class="o">%</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_face_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_faces&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">_FaceAreas</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span>

    <span class="n">faces</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_face_areas</span><span class="p">,</span> \
                         <span class="n">fset</span><span class="o">=</span><span class="n">_set_face_areas</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newick</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">support</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_up</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="n">DEFAULT_DIST</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_support</span> <span class="o">=</span> <span class="n">DEFAULT_SUPPORT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_img_style</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="c1"># Add basic features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">update</span><span class="p">([</span><span class="s2">&quot;dist&quot;</span><span class="p">,</span> <span class="s2">&quot;support&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span>
        <span class="k">if</span> <span class="n">support</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">support</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">DEFAULT_NAME</span>

        <span class="c1"># Initialize tree</span>
        <span class="k">if</span> <span class="n">newick</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dist</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">read_newick</span><span class="p">(</span><span class="n">newick</span><span class="p">,</span> <span class="n">root_node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
                        <span class="n">quoted_names</span><span class="o">=</span><span class="n">quoted_node_names</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Python3&#39;s equivalent of __nonzero__</span>
<span class="sd">        If this is not defined bool(class_instance) will call</span>
<span class="sd">        __len__ in python3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Tree node &#39;</span><span class="si">%s</span><span class="s2">&#39; (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">hex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()))</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This allows to execute tree&amp;&#39;A&#39; to obtain the descendant node</span>
<span class="sd">        whose name is A&quot;&quot;&quot;</span>
        <span class="n">value</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">first_match</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">value</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">first_match</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Node not found&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="TreeNode.__add__"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.__add__">[docs]</a>    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This allows to sum two trees.&quot;&quot;&quot;</span>
        <span class="c1"># Should a make the sum with two copies of the original trees?</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="n">new_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
            <span class="n">new_root</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">new_root</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_root</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Invalid node type&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Print tree in newick format. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ascii</span><span class="p">(</span><span class="n">compact</span><span class="o">=</span><span class="n">DEFAULT_COMPACT</span><span class="p">,</span> \
                                <span class="n">show_internal</span><span class="o">=</span><span class="n">DEFAULT_SHOWINTERNAL</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Check if item belongs to this node. The &#39;item&#39; argument must</span>
<span class="sd">        be a node instance or its associated name.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_descendants</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">()])</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Node len returns number of children.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterator over leaf nodes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">()</span>

<div class="viewcode-block" id="TreeNode.add_feature"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.add_feature">[docs]</a>    <span class="k">def</span> <span class="nf">add_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pr_name</span><span class="p">,</span> <span class="n">pr_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add or update a node&#39;s feature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pr_name</span><span class="p">,</span> <span class="n">pr_value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pr_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.add_features"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.add_features">[docs]</a>    <span class="k">def</span> <span class="nf">add_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">features</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add or update several features. &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fvalue</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">features</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fvalue</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.del_feature"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.del_feature">[docs]</a>    <span class="k">def</span> <span class="nf">del_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pr_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Permanently deletes a node&#39;s feature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pr_name</span><span class="p">):</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pr_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">pr_name</span><span class="p">)</span></div>

    <span class="c1"># Topology management</span>
<div class="viewcode-block" id="TreeNode.add_child"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.add_child">[docs]</a>    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">support</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new child to this node. If child node is not suplied</span>
<span class="sd">        as an argument, a new node instance will be created.</span>

<span class="sd">        :argument None child: the node instance to be added as a child.</span>
<span class="sd">        :argument None name: the name that will be given to the child.</span>
<span class="sd">        :argument None dist: the distance from the node to the child.</span>
<span class="sd">        :argument None support: the support value of child partition.</span>

<span class="sd">        :returns: The child node instance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">child</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span>
        <span class="k">if</span> <span class="n">support</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">support</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">child</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">child</span></div>

<div class="viewcode-block" id="TreeNode.remove_child"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.remove_child">[docs]</a>    <span class="k">def</span> <span class="nf">remove_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a child from this node (parent and child</span>
<span class="sd">        nodes still exit but are no longer connected).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;child not found&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">child</span></div>

<div class="viewcode-block" id="TreeNode.add_sister"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.add_sister">[docs]</a>    <span class="k">def</span> <span class="nf">add_sister</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sister</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a sister to this node. If sister node is not supplied</span>
<span class="sd">        as an argument, a new TreeNode instance will be created and</span>
<span class="sd">        returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;A parent node is required to add a sister&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child</span><span class="o">=</span><span class="n">sister</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.remove_sister"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.remove_sister">[docs]</a>    <span class="k">def</span> <span class="nf">remove_sister</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sister</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a sister node. It has the same effect as</span>
<span class="sd">        **`TreeNode.up.remove_child(sister)`**</span>

<span class="sd">        If a sister node is not supplied, the first sister will be deleted</span>
<span class="sd">        and returned.</span>

<span class="sd">        :argument sister: A node instance</span>

<span class="sd">        :return: The node removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sisters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sisters</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sisters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sister</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sister</span> <span class="o">=</span> <span class="n">sisters</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="n">sister</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.delete"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.delete">[docs]</a>    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prevent_nondicotomic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">preserve_branch_length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes node from the tree structure. Notice that this method</span>
<span class="sd">        makes &#39;disappear&#39; the node from the tree structure. This means</span>
<span class="sd">        that children from the deleted node are transferred to the</span>
<span class="sd">        next available parent.</span>

<span class="sd">        :param True prevent_nondicotomic: When True (default), delete</span>
<span class="sd">            function will be execute recursively to prevent</span>
<span class="sd">            single-child nodes.</span>

<span class="sd">        :param False preserve_branch_length: If True, branch lengths</span>
<span class="sd">            of the deleted nodes are transferred (summed up) to its</span>
<span class="sd">            parent&#39;s branch, thus keeping original distances among</span>
<span class="sd">            nodes.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        ::</span>

<span class="sd">                / C</span>
<span class="sd">          root-|</span>
<span class="sd">               |        / B</span>
<span class="sd">                \--- H |</span>
<span class="sd">                        \ A</span>

<span class="sd">          &gt; H.delete() will produce this structure:</span>

<span class="sd">                / C</span>
<span class="sd">               |</span>
<span class="sd">          root-|--B</span>
<span class="sd">               |</span>
<span class="sd">                \ A</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span>
        <span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">preserve_branch_length</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dist</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">dist</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist</span>

            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

            <span class="n">parent</span><span class="o">.</span><span class="n">remove_child</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Avoids parents with only one child</span>
        <span class="k">if</span> <span class="n">prevent_nondicotomic</span> <span class="ow">and</span> <span class="n">parent</span> <span class="ow">and</span>\
              <span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">prevent_nondicotomic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">preserve_branch_length</span><span class="o">=</span><span class="n">preserve_branch_length</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeNode.detach"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.detach">[docs]</a>    <span class="k">def</span> <span class="nf">detach</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detachs this node (and all its descendants) from its parent</span>
<span class="sd">        and returns the referent to itself.</span>

<span class="sd">        Detached node conserves all its structure of descendants, and can</span>
<span class="sd">        be attached to another node through the &#39;add_child&#39; function. This</span>
<span class="sd">        mechanism can be seen as a cut and paste.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span> <span class="nf">prune</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">preserve_branch_length</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prunes the topology of a node to conserve only the selected list of leaf</span>
<span class="sd">        internal nodes. The minimum number of nodes that conserve the</span>
<span class="sd">        topological relationships among the requested nodes will be</span>
<span class="sd">        retained. Root node is always conserved.</span>

<span class="sd">        :var nodes: a list of node names or node objects that should be retained</span>

<span class="sd">        :param False preserve_branch_length: If True, branch lengths</span>
<span class="sd">          of the deleted nodes are transferred (summed up) to its</span>
<span class="sd">          parent&#39;s branch, thus keeping original distances among</span>
<span class="sd">          nodes.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        ::</span>

<span class="sd">          t1 = Tree(&#39;(((((A,B)C)D,E)F,G)H,(I,J)K)root;&#39;, format=1)</span>
<span class="sd">          t1.prune([&#39;A&#39;, &#39;B&#39;])</span>


<span class="sd">          #                /-A</span>
<span class="sd">          #          /D /C|</span>
<span class="sd">          #       /F|      \-B</span>
<span class="sd">          #      |  |</span>
<span class="sd">          #    /H|   \-E</span>
<span class="sd">          #   |  |                        /-A</span>
<span class="sd">          #-root  \-G                 -root</span>
<span class="sd">          #   |                           \-B</span>
<span class="sd">          #   |   /-I</span>
<span class="sd">          #    \K|</span>
<span class="sd">          #       \-J</span>



<span class="sd">          t1 = Tree(&#39;(((((A,B)C)D,E)F,G)H,(I,J)K)root;&#39;, format=1)</span>
<span class="sd">          t1.prune([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span>

<span class="sd">          #                /-A</span>
<span class="sd">          #          /D /C|</span>
<span class="sd">          #       /F|      \-B</span>
<span class="sd">          #      |  |</span>
<span class="sd">          #    /H|   \-E</span>
<span class="sd">          #   |  |                              /-A</span>
<span class="sd">          #-root  \-G                  -root- C|</span>
<span class="sd">          #   |                                 \-B</span>
<span class="sd">          #   |   /-I</span>
<span class="sd">          #    \K|</span>
<span class="sd">          #       \-J</span>



<span class="sd">          t1 = Tree(&#39;(((((A,B)C)D,E)F,G)H,(I,J)K)root;&#39;, format=1)</span>
<span class="sd">          t1.prune([&#39;A&#39;, &#39;B&#39;, &#39;I&#39;])</span>


<span class="sd">          #                /-A</span>
<span class="sd">          #          /D /C|</span>
<span class="sd">          #       /F|      \-B</span>
<span class="sd">          #      |  |</span>
<span class="sd">          #    /H|   \-E                    /-I</span>
<span class="sd">          #   |  |                      -root</span>
<span class="sd">          #-root  \-G                      |   /-A</span>
<span class="sd">          #   |                             \C|</span>
<span class="sd">          #   |   /-I                          \-B</span>
<span class="sd">          #    \K|</span>
<span class="sd">          #       \-J</span>

<span class="sd">          t1 = Tree(&#39;(((((A,B)C)D,E)F,G)H,(I,J)K)root;&#39;, format=1)</span>
<span class="sd">          t1.prune([&#39;A&#39;, &#39;B&#39;, &#39;F&#39;, &#39;H&#39;])</span>

<span class="sd">          #                /-A</span>
<span class="sd">          #          /D /C|</span>
<span class="sd">          #       /F|      \-B</span>
<span class="sd">          #      |  |</span>
<span class="sd">          #    /H|   \-E</span>
<span class="sd">          #   |  |                              /-A</span>
<span class="sd">          #-root  \-G                -root-H /F|</span>
<span class="sd">          #   |                                 \-B</span>
<span class="sd">          #   |   /-I</span>
<span class="sd">          #    \K|</span>
<span class="sd">          #       \-J</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">cmp_nodes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="c1"># if several nodes are in the same path of two kept nodes,</span>
            <span class="c1"># only one should be maintained. This prioritize internal</span>
            <span class="c1"># nodes that are already in the to_keep list and then</span>
            <span class="c1"># deeper nodes (closer to the leaves).</span>
            <span class="k">if</span> <span class="n">n2depth</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">n2depth</span><span class="p">[</span><span class="n">y</span><span class="p">]:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">n2depth</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">n2depth</span><span class="p">[</span><span class="n">y</span><span class="p">]:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="n">to_keep</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_translate_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes</span><span class="p">))</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">node2path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="n">to_keep</span><span class="p">,</span> <span class="n">get_path</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">to_keep</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Calculate which kept nodes are visiting the same nodes in</span>
        <span class="c1"># their path to the common ancestor.</span>
        <span class="n">n2count</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">n2depth</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">seed</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">node2path</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">visited_node</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">visited_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n2depth</span><span class="p">:</span>
                    <span class="n">depth</span> <span class="o">=</span> <span class="n">visited_node</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">topology_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">n2depth</span><span class="p">[</span><span class="n">visited_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>
                <span class="k">if</span> <span class="n">visited_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">seed</span><span class="p">:</span>
                    <span class="n">n2count</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">visited_node</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># if several internal nodes are in the path of exactly the same kept</span>
        <span class="c1"># nodes, only one (the deepest) should be maintain.</span>
        <span class="n">visitors2nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">visitors</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">n2count</span><span class="p">):</span>
            <span class="c1"># keep nodes connection at least two other nodes</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visitors</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">visitor_key</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">visitors</span><span class="p">)</span>
                <span class="n">visitors2nodes</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">visitor_key</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">visitors</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">visitors2nodes</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">to_keep</span> <span class="o">&amp;</span> <span class="n">nodes</span><span class="p">):</span>
                <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">cmp_to_key</span><span class="p">(</span><span class="n">cmp_nodes</span><span class="p">))</span>
                <span class="n">to_keep</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sorted_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_descendants</span><span class="p">(</span><span class="s1">&#39;postorder&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_keep</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">preserve_branch_length</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dist</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="n">dist</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>
                        <span class="n">n</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">dist</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="n">dist</span>

                <span class="n">n</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">prevent_nondicotomic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<div class="viewcode-block" id="TreeNode.swap_children"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.swap_children">[docs]</a>    <span class="k">def</span> <span class="nf">swap_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Swaps current children order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span></div>


    <span class="c1"># #####################</span>
    <span class="c1"># Tree traversing</span>
    <span class="c1"># #####################</span>


<div class="viewcode-block" id="TreeNode.get_children"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_children">[docs]</a>    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an independent list of node&#39;s children.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span></div>

<div class="viewcode-block" id="TreeNode.get_sisters"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_sisters">[docs]</a>    <span class="k">def</span> <span class="nf">get_sisters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an independent list of sister nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span><span class="o">.</span><span class="n">children</span> <span class="k">if</span> <span class="n">ch</span><span class="o">!=</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="TreeNode.iter_leaves"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.iter_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">iter_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the leaves under this node.</span>

<span class="sd">        :argument None is_leaf_fn: See :func:`TreeNode.traverse` for</span>
<span class="sd">          documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;preorder&quot;</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_leaf_fn</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                    <span class="k">yield</span> <span class="n">n</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_leaf_fn</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">n</span></div>

<div class="viewcode-block" id="TreeNode.get_leaves"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of terminal nodes (leaves) under this node.</span>

<span class="sd">        :argument None is_leaf_fn: See :func:`TreeNode.traverse` for</span>
<span class="sd">          documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">)]</span></div>

<div class="viewcode-block" id="TreeNode.iter_leaf_names"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.iter_leaf_names">[docs]</a>    <span class="k">def</span> <span class="nf">iter_leaf_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the leaf names under this node.</span>

<span class="sd">        :argument None is_leaf_fn: See :func:`TreeNode.traverse` for</span>
<span class="sd">          documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span></div>

<div class="viewcode-block" id="TreeNode.get_leaf_names"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_leaf_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_leaf_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of terminal node names under the current</span>
<span class="sd">        node.</span>

<span class="sd">        :argument None is_leaf_fn: See :func:`TreeNode.traverse` for</span>
<span class="sd">          documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_leaf_names</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">)]</span></div>

<div class="viewcode-block" id="TreeNode.iter_descendants"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.iter_descendants">[docs]</a>    <span class="k">def</span> <span class="nf">iter_descendants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;levelorder&quot;</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all descendant nodes.</span>

<span class="sd">        :argument None is_leaf_fn: See :func:`TreeNode.traverse` for</span>
<span class="sd">          documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">n</span></div>

<div class="viewcode-block" id="TreeNode.get_descendants"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_descendants">[docs]</a>    <span class="k">def</span> <span class="nf">get_descendants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;levelorder&quot;</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of all (leaves and internal) descendant nodes.</span>

<span class="sd">        :argument None is_leaf_fn: See :func:`TreeNode.traverse` for</span>
<span class="sd">          documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="n">strategy</span><span class="p">,</span> \
                                                 <span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">)]</span></div>

<div class="viewcode-block" id="TreeNode.traverse"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.traverse">[docs]</a>    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;levelorder&quot;</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator to traverse the tree structure under this</span>
<span class="sd">        node.</span>

<span class="sd">        :argument &quot;levelorder&quot; strategy: set the way in which tree</span>
<span class="sd">           will be traversed. Possible values are: &quot;preorder&quot; (first</span>
<span class="sd">           parent and then children) &#39;postorder&#39; (first children and</span>
<span class="sd">           the parent) and &quot;levelorder&quot; (nodes are visited in order</span>
<span class="sd">           from root to leaves)</span>

<span class="sd">        :argument None is_leaf_fn: If supplied, ``is_leaf_fn``</span>
<span class="sd">           function will be used to interrogate nodes about if they</span>
<span class="sd">           are terminal or internal. ``is_leaf_fn`` function should</span>
<span class="sd">           receive a node instance as first argument and return True</span>
<span class="sd">           or False. Use this argument to traverse a tree by</span>
<span class="sd">           dynamically collapsing internal nodes matching</span>
<span class="sd">           ``is_leaf_fn``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strategy</span><span class="o">==</span><span class="s2">&quot;preorder&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_descendants_preorder</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">strategy</span><span class="o">==</span><span class="s2">&quot;levelorder&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_descendants_levelorder</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">strategy</span><span class="o">==</span><span class="s2">&quot;postorder&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_descendants_postorder</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.iter_prepostorder"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.iter_prepostorder">[docs]</a>    <span class="k">def</span> <span class="nf">iter_prepostorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all nodes in a tree yielding every node in both</span>
<span class="sd">        pre and post order. Each iteration returns a postorder flag</span>
<span class="sd">        (True if node is being visited in postorder) and a node</span>
<span class="sd">        instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_leaf_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_leaf</span> <span class="o">=</span> <span class="n">is_leaf_fn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">is_leaf</span>

        <span class="k">while</span> <span class="n">to_visit</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># PREORDER ACTIONS</span>
                <span class="k">yield</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_leaf</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="c1"># ADD CHILDREN</span>
                    <span class="n">to_visit</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="o">+</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">]]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#POSTORDER ACTIONS</span>
                <span class="k">yield</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_iter_descendants_postorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_leaf_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_leaf</span> <span class="o">=</span> <span class="n">is_leaf_fn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">is_leaf</span>

        <span class="k">while</span> <span class="n">to_visit</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># PREORDER ACTIONS</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_leaf</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="c1"># ADD CHILDREN</span>
                    <span class="n">to_visit</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="o">+</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">]]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">node</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#POSTORDER ACTIONS</span>
                <span class="k">yield</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">_iter_descendants_levelorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all desdecendant nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tovisit</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">tovisit</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">tovisit</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_leaf_fn</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_leaf_fn</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">tovisit</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_descendants_preorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all descendant nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">node</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_leaf_fn</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_leaf_fn</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">to_visit</span><span class="o">.</span><span class="n">extendleft</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="TreeNode.iter_ancestors"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.iter_ancestors">[docs]</a>    <span class="k">def</span> <span class="nf">iter_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;versionadded: 2.2</span>

<span class="sd">        Iterates over the list of all ancestor nodes from current node</span>
<span class="sd">        to the current tree root.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">up</span></div>

<div class="viewcode-block" id="TreeNode.get_ancestors"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_ancestors">[docs]</a>    <span class="k">def</span> <span class="nf">get_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;versionadded: 2.2</span>

<span class="sd">        Returns the list of all ancestor nodes from current node to</span>
<span class="sd">        the current tree root.</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_ancestors</span><span class="p">()]</span></div>

<div class="viewcode-block" id="TreeNode.describe"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.describe">[docs]</a>    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints general information about this node and its</span>
<span class="sd">        connections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span><span class="o">.</span><span class="n">children</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">rooting</span> <span class="o">=</span> <span class="s2">&quot;Yes&quot;</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span><span class="o">.</span><span class="n">children</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">rooting</span> <span class="o">=</span> <span class="s2">&quot;No&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rooting</span> <span class="o">=</span> <span class="s2">&quot;No children&quot;</span>
        <span class="n">max_node</span><span class="p">,</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_farthest_leaf</span><span class="p">()</span>
        <span class="n">cached_content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of leaf nodes:</span><span class="se">\t</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">cached_content</span><span class="p">[</span><span class="bp">self</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total number of nodes:</span><span class="se">\t</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">cached_content</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rooted:</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">rooting</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Most distant node:</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">max_node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Max. distance:</span><span class="se">\t</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">max_dist</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.write"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">format_root_node</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dist_formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">support_formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">name_formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quoted_node_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the newick representation of current node. Several</span>
<span class="sd">        arguments control the way in which extra data is shown for</span>
<span class="sd">        every node:</span>

<span class="sd">        :argument features: a list of feature names to be exported</span>
<span class="sd">          using the Extended Newick Format (i.e. features=[&quot;name&quot;,</span>
<span class="sd">          &quot;dist&quot;]). Use an empty list to export all available features</span>
<span class="sd">          in each node (features=[])</span>

<span class="sd">        :argument outfile: writes the output to a given file</span>

<span class="sd">        :argument format: defines the newick standard used to encode the</span>
<span class="sd">          tree. See tutorial for details.</span>

<span class="sd">        :argument False format_root_node: If True, it allows features</span>
<span class="sd">          and branch information from root node to be exported as a</span>
<span class="sd">          part of the newick text string. For newick compatibility</span>
<span class="sd">          reasons, this is False by default.</span>

<span class="sd">        :argument is_leaf_fn: See :func:`TreeNode.traverse` for</span>
<span class="sd">          documentation.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        ::</span>

<span class="sd">             t.write(features=[&quot;species&quot;,&quot;name&quot;], format=1)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nw</span> <span class="o">=</span> <span class="n">write_newick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="n">features</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
                          <span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">,</span>
                          <span class="n">format_root_node</span><span class="o">=</span><span class="n">format_root_node</span><span class="p">,</span>
                          <span class="n">dist_formatter</span><span class="o">=</span><span class="n">dist_formatter</span><span class="p">,</span>
                          <span class="n">support_formatter</span><span class="o">=</span><span class="n">support_formatter</span><span class="p">,</span>
                          <span class="n">name_formatter</span><span class="o">=</span><span class="n">name_formatter</span><span class="p">,</span>
                          <span class="n">quoted_names</span><span class="o">=</span><span class="n">quoted_node_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">outfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">OUT</span><span class="p">:</span>
                <span class="n">OUT</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nw</span></div>

<div class="viewcode-block" id="TreeNode.get_tree_root"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_tree_root">[docs]</a>    <span class="k">def</span> <span class="nf">get_tree_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the absolute root node of current tree structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">root</span><span class="o">.</span><span class="n">up</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">up</span>
        <span class="k">return</span> <span class="n">root</span></div>

<div class="viewcode-block" id="TreeNode.get_common_ancestor"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_common_ancestor">[docs]</a>    <span class="k">def</span> <span class="nf">get_common_ancestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">target_nodes</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first common ancestor between this node and a given</span>
<span class="sd">        list of &#39;target_nodes&#39;.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        ::</span>

<span class="sd">          t = tree.Tree(&quot;(((A:0.1, B:0.01):0.001, C:0.0001):1.0[&amp;&amp;NHX:name=common], (D:0.00001):0.000001):2.0[&amp;&amp;NHX:name=root];&quot;)</span>
<span class="sd">          A = t.get_descendants_by_name(&quot;A&quot;)[0]</span>
<span class="sd">          C = t.get_descendants_by_name(&quot;C&quot;)[0]</span>
<span class="sd">          common =  A.get_common_ancestor(C)</span>
<span class="sd">          print common.name</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">get_path</span> <span class="o">=</span> <span class="n">kargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;get_path&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> \
                <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="nb">set</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">]):</span>
            <span class="n">target_nodes</span> <span class="o">=</span> <span class="n">target_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Convert node names into node instances</span>
        <span class="n">target_nodes</span> <span class="o">=</span> <span class="n">_translate_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">target_nodes</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">target_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="c1"># If only one node is provided and is the same as the seed node,</span>
            <span class="c1"># return itself</span>
            <span class="k">if</span> <span class="n">target_nodes</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">get_path</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="p">{}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#Otherwise find the common ancestor of current seed node and</span>
                <span class="c1">#the target_node provided</span>
                <span class="n">target_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>

        <span class="n">n2path</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ref_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">target_nodes</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
                <span class="n">n2path</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ref_node</span><span class="p">:</span>
                    <span class="n">reference</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">up</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ref_node</span><span class="p">:</span>
                <span class="n">ref_node</span> <span class="o">=</span> <span class="n">n</span>

        <span class="n">common</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">reference</span><span class="p">:</span>
            <span class="n">broken</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">n2path</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ref_node</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                    <span class="n">broken</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">broken</span><span class="p">:</span>
                <span class="n">common</span> <span class="o">=</span> <span class="n">n</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">common</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Nodes are not connected!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">get_path</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">common</span><span class="p">,</span> <span class="n">n2path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">common</span></div>

<div class="viewcode-block" id="TreeNode.iter_search_nodes"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.iter_search_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">iter_search_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">conditions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Search nodes in an iterative way. Matches are yielded as they</span>
<span class="sd">        are being found. This avoids needing to scan the full tree</span>
<span class="sd">        topology before returning the first matches. Useful when</span>
<span class="sd">        dealing with huge trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="n">conditions_passed</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">conditions</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                    <span class="n">conditions_passed</span> <span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">conditions_passed</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">conditions</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">n</span></div>

<div class="viewcode-block" id="TreeNode.search_nodes"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.search_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">search_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">conditions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of nodes matching a given set of conditions.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        ::</span>

<span class="sd">          tree.search_nodes(dist=0.0, name=&quot;human&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matching_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_search_nodes</span><span class="p">(</span><span class="o">**</span><span class="n">conditions</span><span class="p">):</span>
            <span class="n">matching_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">matching_nodes</span></div>

<div class="viewcode-block" id="TreeNode.get_leaves_by_name"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_leaves_by_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_leaves_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of leaf nodes matching a given name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">[])</span></div>

<div class="viewcode-block" id="TreeNode.is_leaf"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.is_leaf">[docs]</a>    <span class="k">def</span> <span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if current node is a leaf.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="TreeNode.is_root"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.is_root">[docs]</a>    <span class="k">def</span> <span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if current node has no parent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    <span class="c1"># ###########################</span>
    <span class="c1"># Distance related functions</span>
    <span class="c1"># ###########################</span>
<div class="viewcode-block" id="TreeNode.get_distance"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">target2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">topology_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance between two nodes. If only one target is</span>
<span class="sd">        specified, it returns the distance between the target and the</span>
<span class="sd">        current node.</span>

<span class="sd">        :argument target: a node within the same tree structure.</span>

<span class="sd">        :argument target2: a node within the same tree structure. If</span>
<span class="sd">          not specified, current node is used as target2.</span>

<span class="sd">        :argument False topology_only: If set to True, distance will</span>
<span class="sd">          refer to the number of nodes between target and target2.</span>

<span class="sd">        :returns: branch length distance between target and</span>
<span class="sd">          target2. If topology_only flag is True, returns the number</span>
<span class="sd">          of nodes between target and target2.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">target2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">target2</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># is target node under current node?</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">target</span><span class="p">,</span> <span class="n">target2</span> <span class="o">=</span> <span class="n">_translate_nodes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">target2</span><span class="p">)</span>
        <span class="n">ancestor</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">target2</span><span class="p">)</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="n">target2</span><span class="p">,</span> <span class="n">target</span><span class="p">]:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">while</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">ancestor</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">topology_only</span><span class="p">:</span>
                    <span class="k">if</span>  <span class="n">current</span><span class="o">!=</span><span class="n">target</span><span class="p">:</span>
                        <span class="n">dist</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dist</span> <span class="o">+=</span> <span class="n">current</span><span class="o">.</span><span class="n">dist</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">up</span>
        <span class="k">return</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="TreeNode.get_farthest_node"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_farthest_node">[docs]</a>    <span class="k">def</span> <span class="nf">get_farthest_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the node&#39;s farthest descendant or ancestor node, and the</span>
<span class="sd">        distance to it.</span>

<span class="sd">        :argument False topology_only: If set to True, distance</span>
<span class="sd">          between nodes will be referred to the number of nodes</span>
<span class="sd">          between them. In other words, topological distance will be</span>
<span class="sd">          used instead of branch length distances.</span>

<span class="sd">        :return: A tuple containing the farthest node referred to the</span>
<span class="sd">          current node and the distance to it.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Init farthest node to current farthest leaf</span>
        <span class="n">farthest_node</span><span class="p">,</span> <span class="n">farthest_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_farthest_leaf</span><span class="p">(</span><span class="n">topology_only</span><span class="o">=</span><span class="n">topology_only</span><span class="p">)</span>

        <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">cdist</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">topology_only</span> <span class="k">else</span> <span class="n">prev</span><span class="o">.</span><span class="n">dist</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">up</span>
        <span class="k">while</span> <span class="n">current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">current</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ch</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ch</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                        <span class="n">fnode</span><span class="p">,</span> <span class="n">fdist</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">get_farthest_leaf</span><span class="p">(</span><span class="n">topology_only</span><span class="o">=</span><span class="n">topology_only</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fnode</span> <span class="o">=</span> <span class="n">ch</span>
                        <span class="n">fdist</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">topology_only</span><span class="p">:</span>
                        <span class="n">fdist</span> <span class="o">+=</span> <span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fdist</span> <span class="o">+=</span> <span class="n">ch</span><span class="o">.</span><span class="n">dist</span>
                    <span class="k">if</span> <span class="n">cdist</span><span class="o">+</span><span class="n">fdist</span> <span class="o">&gt;</span> <span class="n">farthest_dist</span><span class="p">:</span>
                        <span class="n">farthest_dist</span> <span class="o">=</span> <span class="n">cdist</span> <span class="o">+</span> <span class="n">fdist</span>
                        <span class="n">farthest_node</span> <span class="o">=</span> <span class="n">fnode</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span>
            <span class="k">if</span> <span class="n">topology_only</span><span class="p">:</span>
                <span class="n">cdist</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cdist</span>  <span class="o">+=</span> <span class="n">prev</span><span class="o">.</span><span class="n">dist</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">up</span>
        <span class="k">return</span> <span class="n">farthest_node</span><span class="p">,</span> <span class="n">farthest_dist</span></div>

    <span class="k">def</span> <span class="nf">_get_farthest_and_closest_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># if called from a leaf node, no necessary to compute</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_leaf_fn</span> <span class="ow">and</span> <span class="n">is_leaf_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="mf">0.0</span>

        <span class="n">min_dist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">min_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_dist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_node</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">post</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_prepostorder</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">post</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">-=</span> <span class="n">n</span><span class="o">.</span><span class="n">dist</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">topology_only</span> <span class="k">else</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">is_leaf_fn</span> <span class="ow">and</span> <span class="n">is_leaf_fn</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                    <span class="n">total_d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="n">dist</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">topology_only</span> <span class="k">else</span> <span class="n">d</span>
                    <span class="k">if</span> <span class="n">min_dist</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">total_d</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">total_d</span>
                        <span class="n">min_node</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="k">if</span> <span class="n">max_dist</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">total_d</span> <span class="o">&gt;</span> <span class="n">max_dist</span><span class="p">:</span>
                        <span class="n">max_dist</span> <span class="o">=</span> <span class="n">total_d</span>
                        <span class="n">max_node</span> <span class="o">=</span> <span class="n">n</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="n">dist</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">topology_only</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">min_node</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">max_node</span><span class="p">,</span> <span class="n">max_dist</span>


<div class="viewcode-block" id="TreeNode.get_farthest_leaf"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_farthest_leaf">[docs]</a>    <span class="k">def</span> <span class="nf">get_farthest_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns node&#39;s farthest descendant node (which is always a leaf), and the</span>
<span class="sd">        distance to it.</span>

<span class="sd">        :argument False topology_only: If set to True, distance</span>
<span class="sd">          between nodes will be referred to the number of nodes</span>
<span class="sd">          between them. In other words, topological distance will be</span>
<span class="sd">          used instead of branch length distances.</span>

<span class="sd">        :return: A tuple containing the farthest leaf referred to the</span>
<span class="sd">          current node and the distance to it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_node</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">max_node</span><span class="p">,</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_farthest_and_closest_leaves</span><span class="p">(</span>
        <span class="n">topology_only</span><span class="o">=</span><span class="n">topology_only</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">max_node</span><span class="p">,</span> <span class="n">max_dist</span></div>

<div class="viewcode-block" id="TreeNode.get_closest_leaf"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_closest_leaf">[docs]</a>    <span class="k">def</span> <span class="nf">get_closest_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns node&#39;s closest descendant leaf and the distance to</span>
<span class="sd">        it.</span>

<span class="sd">        :argument False topology_only: If set to True, distance</span>
<span class="sd">          between nodes will be referred to the number of nodes</span>
<span class="sd">          between them. In other words, topological distance will be</span>
<span class="sd">          used instead of branch length distances.</span>

<span class="sd">        :return: A tuple containing the closest leaf referred to the</span>
<span class="sd">          current node and the distance to it.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">min_node</span><span class="p">,</span> <span class="n">min_dist</span><span class="p">,</span> <span class="n">max_node</span><span class="p">,</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_farthest_and_closest_leaves</span><span class="p">(</span>
            <span class="n">topology_only</span><span class="o">=</span><span class="n">topology_only</span><span class="p">,</span> <span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_leaf_fn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">min_node</span><span class="p">,</span> <span class="n">min_dist</span></div>


<div class="viewcode-block" id="TreeNode.get_midpoint_outgroup"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_midpoint_outgroup">[docs]</a>    <span class="k">def</span> <span class="nf">get_midpoint_outgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the node that divides the current tree into two distance-balanced</span>
<span class="sd">        partitions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gets the farthest node to the current root</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span>
        <span class="n">nA</span><span class="p">,</span> <span class="n">r2A_dist</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">get_farthest_leaf</span><span class="p">()</span>
        <span class="n">nB</span><span class="p">,</span> <span class="n">A2B_dist</span> <span class="o">=</span> <span class="n">nA</span><span class="o">.</span><span class="n">get_farthest_node</span><span class="p">()</span>

        <span class="n">outgroup</span> <span class="o">=</span> <span class="n">nA</span>
        <span class="n">middist</span>  <span class="o">=</span> <span class="n">A2B_dist</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">cdist</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">nA</span>
        <span class="k">while</span> <span class="n">current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cdist</span> <span class="o">+=</span> <span class="n">current</span><span class="o">.</span><span class="n">dist</span>
            <span class="k">if</span> <span class="n">cdist</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">middist</span><span class="p">):</span> <span class="c1"># Deja de subir cuando se pasa del maximo</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">up</span>

        <span class="c1"># if we reached the root, the tree is already at midpoint. Return any child as valid outgroup</span>
        <span class="k">if</span> <span class="n">current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">current</span></div>

<div class="viewcode-block" id="TreeNode.populate"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.populate">[docs]</a>    <span class="k">def</span> <span class="nf">populate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">names_library</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reuse_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">random_branches</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">branch_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
                 <span class="n">support_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random topology by populating current node.</span>

<span class="sd">        :argument None names_library: If provided, names library</span>
<span class="sd">          (list, set, dict, etc.) will be used to name nodes.</span>

<span class="sd">        :argument False reuse_names: If True, node names will not be</span>
<span class="sd">          necessarily unique, which makes the process a bit more</span>
<span class="sd">          efficient.</span>

<span class="sd">        :argument False random_branches: If True, branch distances and support</span>
<span class="sd">          values will be randomized.</span>

<span class="sd">        :argument (0,1) branch_range: If random_branches is True, this</span>
<span class="sd">          range of values will be used to generate random distances.</span>

<span class="sd">        :argument (0,1) support_range: If random_branches is True,</span>
<span class="sd">          this range of values will be used to generate random branch</span>
<span class="sd">          support values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">NewNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">connector</span> <span class="o">=</span> <span class="n">NewNode</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                <span class="n">connector</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child</span> <span class="o">=</span> <span class="n">ch</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">NewNode</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child</span> <span class="o">=</span> <span class="n">connector</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">child</span> <span class="o">=</span> <span class="n">root</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">next_deq</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">next_deq</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">next_deq</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

            <span class="n">c1</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">add_child</span><span class="p">()</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">add_child</span><span class="p">()</span>
            <span class="n">next_deq</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">random_branches</span><span class="p">:</span>
                <span class="n">c1</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">*</span><span class="n">branch_range</span><span class="p">)</span>
                <span class="n">c2</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">*</span><span class="n">branch_range</span><span class="p">)</span>
                <span class="n">c1</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">*</span><span class="n">branch_range</span><span class="p">)</span>
                <span class="n">c2</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">*</span><span class="n">branch_range</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c1</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">c2</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">c1</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">c2</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># next contains leaf nodes</span>
        <span class="n">charset</span> <span class="o">=</span>  <span class="s2">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
        <span class="k">if</span> <span class="n">names_library</span><span class="p">:</span>
            <span class="n">names_library</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">names_library</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">avail_names</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">charset</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">next_deq</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">names_library</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">reuse_names</span><span class="p">:</span>
                    <span class="n">tname</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">names_library</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tname</span> <span class="o">=</span> <span class="n">names_library</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tname</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">avail_names</span><span class="p">))</span>
            <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tname</span></div>


<div class="viewcode-block" id="TreeNode.set_outgroup"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.set_outgroup">[docs]</a>    <span class="k">def</span> <span class="nf">set_outgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outgroup</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a descendant node as the outgroup of a tree.  This function</span>
<span class="sd">        can be used to root a tree or even an internal node.</span>

<span class="sd">        :argument outgroup: a node instance within the same tree</span>
<span class="sd">          structure that will be used as a basal node.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">outgroup</span> <span class="o">=</span> <span class="n">_translate_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outgroup</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">outgroup</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Cannot set myself as outgroup&quot;</span><span class="p">)</span>

        <span class="n">parent_outgroup</span> <span class="o">=</span> <span class="n">outgroup</span><span class="o">.</span><span class="n">up</span>

        <span class="c1"># Detects (sub)tree root</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">outgroup</span>
        <span class="k">while</span> <span class="n">n</span><span class="o">.</span><span class="n">up</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">up</span>

        <span class="c1"># If outgroup is a child from root, but with more than one</span>
        <span class="c1"># sister nodes, creates a new node to group them</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">down_branch_connector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
            <span class="n">down_branch_connector</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">down_branch_connector</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">support</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
                <span class="n">down_branch_connector</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">down_branch_connector</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">down_branch_connector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Connects down branch to myself or to outgroup</span>
        <span class="n">quien_va_ser_padre</span> <span class="o">=</span> <span class="n">parent_outgroup</span>
        <span class="k">if</span> <span class="n">quien_va_ser_padre</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="c1"># Parent-child swapping</span>
            <span class="n">quien_va_ser_hijo</span> <span class="o">=</span> <span class="n">quien_va_ser_padre</span><span class="o">.</span><span class="n">up</span>
            <span class="n">quien_fue_padre</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">buffered_dist</span> <span class="o">=</span> <span class="n">quien_va_ser_padre</span><span class="o">.</span><span class="n">dist</span>
            <span class="n">buffered_support</span> <span class="o">=</span> <span class="n">quien_va_ser_padre</span><span class="o">.</span><span class="n">support</span>

            <span class="k">while</span> <span class="n">quien_va_ser_hijo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">quien_va_ser_padre</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quien_va_ser_hijo</span><span class="p">)</span>
                <span class="n">quien_va_ser_hijo</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">quien_va_ser_padre</span><span class="p">)</span>

                <span class="n">buffered_dist2</span> <span class="o">=</span> <span class="n">quien_va_ser_hijo</span><span class="o">.</span><span class="n">dist</span>
                <span class="n">buffered_support2</span> <span class="o">=</span> <span class="n">quien_va_ser_hijo</span><span class="o">.</span><span class="n">support</span>
                <span class="n">quien_va_ser_hijo</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">buffered_dist</span>
                <span class="n">quien_va_ser_hijo</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">buffered_support</span>
                <span class="n">buffered_dist</span> <span class="o">=</span> <span class="n">buffered_dist2</span>
                <span class="n">buffered_support</span> <span class="o">=</span> <span class="n">buffered_support2</span>

                <span class="n">quien_va_ser_padre</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">quien_fue_padre</span>
                <span class="n">quien_fue_padre</span> <span class="o">=</span> <span class="n">quien_va_ser_padre</span>

                <span class="n">quien_va_ser_padre</span> <span class="o">=</span> <span class="n">quien_va_ser_hijo</span>
                <span class="n">quien_va_ser_hijo</span> <span class="o">=</span> <span class="n">quien_va_ser_padre</span><span class="o">.</span><span class="n">up</span>

            <span class="n">quien_va_ser_padre</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">down_branch_connector</span><span class="p">)</span>
            <span class="n">down_branch_connector</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">quien_va_ser_padre</span>
            <span class="n">quien_va_ser_padre</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">quien_fue_padre</span>

            <span class="n">down_branch_connector</span><span class="o">.</span><span class="n">dist</span> <span class="o">+=</span> <span class="n">buffered_dist</span>
            <span class="n">outgroup2</span> <span class="o">=</span> <span class="n">parent_outgroup</span>
            <span class="n">parent_outgroup</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">outgroup</span><span class="p">)</span>
            <span class="n">outgroup2</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">outgroup2</span> <span class="o">=</span> <span class="n">down_branch_connector</span>

        <span class="n">outgroup</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">outgroup2</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># outgroup is always the first children. Some function my</span>
        <span class="c1"># trust on this fact, so do no change this.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">outgroup</span><span class="p">,</span><span class="n">outgroup2</span><span class="p">]</span>
        <span class="n">middist</span> <span class="o">=</span> <span class="p">(</span><span class="n">outgroup2</span><span class="o">.</span><span class="n">dist</span> <span class="o">+</span> <span class="n">outgroup</span><span class="o">.</span><span class="n">dist</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">outgroup</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">middist</span>
        <span class="n">outgroup2</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">middist</span>
        <span class="n">outgroup2</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">outgroup</span><span class="o">.</span><span class="n">support</span></div>

<div class="viewcode-block" id="TreeNode.unroot"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.unroot">[docs]</a>    <span class="k">def</span> <span class="nf">unroot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;legacy&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unroots current node. This function is expected to be used on</span>
<span class="sd">        the absolute tree root node, but it can be also be applied to</span>
<span class="sd">        any other internal node. It will convert a split into a</span>
<span class="sd">        multifurcation.</span>

<span class="sd">        :argument &quot;legacy&quot; mode: The value can be &quot;legacy&quot; or &quot;keep&quot;.</span>
<span class="sd">        If value is &quot;keep&quot;, then function keeps the distance between</span>
<span class="sd">        the leaves by adding the distance associated to the deleted</span>
<span class="sd">        edge to the remaining edge. In the other case the distance</span>
<span class="sd">        value of the deleted edge is dropped</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;legacy&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;keep&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The value of the mode parameter must be &#39;legacy&#39; or &#39;keep&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;keep&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dist</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dist</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;keep&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dist</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dist</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Cannot unroot a tree with only two leaves&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.show"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tree_style</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ETE&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts an interactive session to visualize current node</span>
<span class="sd">        structure using provided layout and TreeStyle.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..treeview</span> <span class="kn">import</span> <span class="n">drawer</span>
        <span class="n">drawer</span><span class="o">.</span><span class="n">show_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span>
                         <span class="n">tree_style</span><span class="o">=</span><span class="n">tree_style</span><span class="p">,</span> <span class="n">win_name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> \
                       <span class="n">tree_style</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;px&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">90</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Renders the node structure as an image.</span>

<span class="sd">        :var file_name: path to the output image file. valid</span>
<span class="sd">          extensions are .SVG, .PDF, .PNG</span>

<span class="sd">        :var layout: a layout function or a valid layout function name</span>

<span class="sd">        :var tree_style: a `TreeStyle` instance containing the image</span>
<span class="sd">          properties</span>

<span class="sd">        :var px units: &quot;px&quot;: pixels, &quot;mm&quot;: millimeters, &quot;in&quot;: inches</span>
<span class="sd">        :var None h: height of the image in :attr:`units`</span>
<span class="sd">        :var None w: width of the image in :attr:`units`</span>
<span class="sd">        :var 90 dpi: dots per inches.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">..treeview</span> <span class="kn">import</span> <span class="n">drawer</span>
        <span class="k">if</span> <span class="n">file_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%%</span><span class="s1">return&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">drawer</span><span class="o">.</span><span class="n">get_img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                                  <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span> <span class="n">tree_style</span><span class="o">=</span><span class="n">tree_style</span><span class="p">,</span>
                                  <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">,</span> <span class="n">return_format</span><span class="o">=</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">drawer</span><span class="o">.</span><span class="n">render_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                                    <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span> <span class="n">tree_style</span><span class="o">=</span><span class="n">tree_style</span><span class="p">,</span>
                                      <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>

<div class="viewcode-block" id="TreeNode.copy"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;cpickle&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;.. versionadded: 2.1</span>

<span class="sd">        Returns a copy of the current node.</span>

<span class="sd">        :var cpickle method: Protocol used to copy the node</span>
<span class="sd">        structure. The following values are accepted:</span>

<span class="sd">           - &quot;newick&quot;: Tree topology, node names, branch lengths and</span>
<span class="sd">             branch support values will be copied by as represented in</span>
<span class="sd">             the newick string (copy by newick string serialisation).</span>

<span class="sd">           - &quot;newick-extended&quot;: Tree topology and all node features</span>
<span class="sd">             will be copied based on the extended newick format</span>
<span class="sd">             representation. Only node features will be copied, thus</span>
<span class="sd">             excluding other node attributes. As this method is also</span>
<span class="sd">             based on newick serialisation, features will be converted</span>
<span class="sd">             into text strings when making the copy.</span>

<span class="sd">           - &quot;cpickle&quot;: The whole node structure and its content is</span>
<span class="sd">             cloned based on cPickle object serialisation (slower, but</span>
<span class="sd">             recommended for full tree copying)</span>

<span class="sd">           - &quot;deepcopy&quot;: The whole node structure and its content is</span>
<span class="sd">             copied based on the standard &quot;copy&quot; Python functionality</span>
<span class="sd">             (this is the slowest method but it allows to copy complex</span>
<span class="sd">             objects even if attributes point to lambda functions,</span>
<span class="sd">             etc.)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;newick&quot;</span><span class="p">:</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">format_root_node</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;newick-extended&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">[],</span> <span class="n">format_root_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">features</span><span class="o">=</span><span class="p">[]))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;deepcopy&quot;</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;cpickle&quot;</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">up</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">cPickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">moves</span><span class="o">.</span><span class="n">cPickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">up</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Invalid copy method&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_node</span></div>

    <span class="k">def</span> <span class="nf">_asciiArt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">char1</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">show_internal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the ASCII representation of the tree.</span>

<span class="sd">        Code based on the PyCogent GPL project.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
        <span class="n">node_name</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attributes</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)]))</span>

        <span class="n">LEN</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="ow">or</span> <span class="n">show_internal</span> <span class="k">else</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">PAD</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="n">LEN</span>
        <span class="n">PA</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">mids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">char2</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span>
                <span class="k">elif</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">char2</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span>
                <span class="k">elif</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">char2</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">char2</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
                <span class="p">(</span><span class="n">clines</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">_asciiArt</span><span class="p">(</span><span class="n">char2</span><span class="p">,</span> <span class="n">show_internal</span><span class="p">,</span> <span class="n">compact</span><span class="p">,</span> <span class="n">attributes</span><span class="p">)</span>
                <span class="n">mids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mid</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">clines</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">compact</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">compact</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">mids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
            <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">PAD</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">PA</span><span class="o">+</span><span class="s1">&#39;|&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">lo</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">PAD</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">hi</span><span class="p">)</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">lo</span> <span class="o">+</span> <span class="n">hi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">prefixes</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">char1</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">LEN</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">prefixes</span><span class="p">[</span><span class="n">mid</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">+</span><span class="n">l</span> <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prefixes</span><span class="p">,</span> <span class="n">result</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">show_internal</span><span class="p">:</span>
                <span class="n">stem</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">stem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">node_name</span> <span class="o">+</span> <span class="n">stem</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">([</span><span class="n">char1</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="n">node_name</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="TreeNode.get_ascii"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_ascii">[docs]</a>    <span class="k">def</span> <span class="nf">get_ascii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_internal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string containing an ascii drawing of the tree.</span>

<span class="sd">        :argument show_internal: includes internal edge names.</span>
<span class="sd">        :argument compact: use exactly one line per tip.</span>

<span class="sd">        :param attributes: A list of node attributes to shown in the</span>
<span class="sd">            ASCII representation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asciiArt</span><span class="p">(</span><span class="n">show_internal</span><span class="o">=</span><span class="n">show_internal</span><span class="p">,</span>
                                      <span class="n">compact</span><span class="o">=</span><span class="n">compact</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="n">attributes</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeNode.ladderize"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.ladderize">[docs]</a>    <span class="k">def</span> <span class="nf">ladderize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded: 2.1</span>

<span class="sd">        Sort the branches of a given tree (swapping children nodes)</span>
<span class="sd">        according to the size of each partition.</span>

<span class="sd">        ::</span>

<span class="sd">           t =  Tree(&quot;(f,((d, ((a,b),c)),e));&quot;)</span>

<span class="sd">           print t</span>

<span class="sd">           #</span>
<span class="sd">           #      /-f</span>
<span class="sd">           #     |</span>
<span class="sd">           #     |          /-d</span>
<span class="sd">           # ----|         |</span>
<span class="sd">           #     |     /---|          /-a</span>
<span class="sd">           #     |    |    |     /---|</span>
<span class="sd">           #     |    |     \---|     \-b</span>
<span class="sd">           #      \---|         |</span>
<span class="sd">           #          |          \-c</span>
<span class="sd">           #          |</span>
<span class="sd">           #           \-e</span>

<span class="sd">           t.ladderize()</span>
<span class="sd">           print t</span>

<span class="sd">           #      /-f</span>
<span class="sd">           # ----|</span>
<span class="sd">           #     |     /-e</span>
<span class="sd">           #      \---|</span>
<span class="sd">           #          |     /-d</span>
<span class="sd">           #           \---|</span>
<span class="sd">           #               |     /-c</span>
<span class="sd">           #                \---|</span>
<span class="sd">           #                    |     /-a</span>
<span class="sd">           #                     \---|</span>
<span class="sd">           #                          \-b</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">n2s</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">():</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">ladderize</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span>
                <span class="n">n2s</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">n2s</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">n2s</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">size</span></div>

<div class="viewcode-block" id="TreeNode.sort_descendants"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.sort_descendants">[docs]</a>    <span class="k">def</span> <span class="nf">sort_descendants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded: 2.1</span>

<span class="sd">        Sort the branches of a given tree by node names. After the</span>
<span class="sd">        tree is sorted. Note that if duplicated names are present,</span>
<span class="sd">        extra criteria should be added to sort nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">node2content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">(</span><span class="n">store_attr</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span> <span class="n">container_type</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">node2content</span><span class="p">[</span><span class="n">x</span><span class="p">])))</span></div>

<div class="viewcode-block" id="TreeNode.get_cached_content"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_cached_content">[docs]</a>    <span class="k">def</span> <span class="nf">get_cached_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">container_type</span><span class="o">=</span><span class="nb">set</span><span class="p">,</span> <span class="n">leaves_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_store</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded: 2.2</span>

<span class="sd">        Returns a dictionary pointing to the preloaded content of each</span>
<span class="sd">        internal node under this tree. Such a dictionary is intended</span>
<span class="sd">        to work as a cache for operations that require many traversal</span>
<span class="sd">        operations.</span>

<span class="sd">        :param None store_attr: Specifies the node attribute that</span>
<span class="sd">            should be cached (i.e. name, distance, etc.). When none,</span>
<span class="sd">            the whole node instance is cached.</span>

<span class="sd">        :param _store: (internal use)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">_store</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_store</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="n">_n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">store_attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">_n</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store_attr</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                    <span class="n">_val</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_n</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">store_attr</span><span class="p">)]</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_val</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_n</span><span class="p">,</span> <span class="n">store_attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>

            <span class="k">return</span> <span class="n">_val</span>

        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">ch</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">(</span><span class="n">store_attr</span><span class="o">=</span><span class="n">store_attr</span><span class="p">,</span>
                                  <span class="n">container_type</span><span class="o">=</span><span class="n">container_type</span><span class="p">,</span>
                                  <span class="n">leaves_only</span><span class="o">=</span><span class="n">leaves_only</span><span class="p">,</span>
                                  <span class="n">_store</span><span class="o">=</span><span class="n">_store</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">leaves_only</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">container_type</span><span class="p">(</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">container_type</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_store</span><span class="p">[</span><span class="n">ch</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">:</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_store</span><span class="p">[</span><span class="n">ch</span><span class="p">])</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">leaves_only</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                        <span class="n">val</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get_value</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">:</span>
                        <span class="n">val</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">get_value</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>

            <span class="n">_store</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_store</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">container_type</span><span class="p">(</span><span class="n">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">_store</span></div>

<div class="viewcode-block" id="TreeNode.robinson_foulds"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.robinson_foulds">[docs]</a>    <span class="k">def</span> <span class="nf">robinson_foulds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">attr_t1</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">attr_t2</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span>
                        <span class="n">unrooted_trees</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">expand_polytomies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">polytomy_size_limit</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">skip_large_polytomies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">correct_by_polytomy_size</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_support_t1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                        <span class="n">min_support_t2</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded: 2.2</span>

<span class="sd">        Returns the Robinson-Foulds symmetric distance between current</span>
<span class="sd">        tree and a different tree instance.</span>

<span class="sd">        :param t2: reference tree</span>

<span class="sd">        :param name attr_t1: Compare trees using a custom node</span>
<span class="sd">                              attribute as a node name.</span>

<span class="sd">        :param name attr_t2: Compare trees using a custom node</span>
<span class="sd">                              attribute as a node name in target tree.</span>

<span class="sd">        :param False attr_t2: If True, consider trees as unrooted.</span>

<span class="sd">        :param False expand_polytomies: If True, all polytomies in the reference</span>
<span class="sd">           and target tree will be expanded into all possible binary</span>
<span class="sd">           trees. Robinson-foulds distance will be calculated between all</span>
<span class="sd">           tree combinations and the minimum value will be returned.</span>
<span class="sd">           See also, :func:`NodeTree.expand_polytomy`.</span>

<span class="sd">        :returns: (rf, rf_max, common_attrs, names, edges_t1, edges_t2,  discarded_edges_t1, discarded_edges_t2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_t</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">target_t</span> <span class="o">=</span> <span class="n">t2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unrooted_trees</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_t</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_t</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Unrooted tree found! You may want to activate the unrooted_trees flag.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expand_polytomies</span> <span class="ow">and</span> <span class="n">correct_by_polytomy_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;expand_polytomies and correct_by_polytomy_size are mutually exclusive.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expand_polytomies</span> <span class="ow">and</span> <span class="n">unrooted_trees</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;expand_polytomies and unrooted_trees arguments cannot be enabled at the same time&quot;</span><span class="p">)</span>


        <span class="n">attrs_t1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ref_t</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)])</span>
        <span class="n">attrs_t2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">target_t</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)])</span>
        <span class="n">common_attrs</span> <span class="o">=</span> <span class="n">attrs_t1</span> <span class="o">&amp;</span> <span class="n">attrs_t2</span>
        <span class="c1"># release mem</span>
        <span class="n">attrs_t1</span><span class="p">,</span> <span class="n">attrs_t2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># Check for duplicated items (is it necessary? can we optimize? what&#39;s the impact in performance?&#39;)</span>
        <span class="n">size1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="kc">True</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ref_t</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">()</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">])</span>
        <span class="n">size2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="kc">True</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">target_t</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">()</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">size1</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_attrs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s1">&#39;Duplicated items found in source tree&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size2</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_attrs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s1">&#39;Duplicated items found in reference tree&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expand_polytomies</span><span class="p">:</span>
            <span class="n">ref_trees</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tree</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span> <span class="k">for</span> <span class="n">nw</span> <span class="ow">in</span>
                         <span class="n">ref_t</span><span class="o">.</span><span class="n">expand_polytomies</span><span class="p">(</span><span class="n">map_attr</span><span class="o">=</span><span class="n">attr_t1</span><span class="p">,</span>
                                                 <span class="n">polytomy_size_limit</span><span class="o">=</span><span class="n">polytomy_size_limit</span><span class="p">,</span>
                                                 <span class="n">skip_large_polytomies</span><span class="o">=</span><span class="n">skip_large_polytomies</span><span class="p">)]</span>
            <span class="n">target_trees</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tree</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span> <span class="k">for</span> <span class="n">nw</span> <span class="ow">in</span>
                            <span class="n">target_t</span><span class="o">.</span><span class="n">expand_polytomies</span><span class="p">(</span><span class="n">map_attr</span><span class="o">=</span><span class="n">attr_t2</span><span class="p">,</span>
                                                       <span class="n">polytomy_size_limit</span><span class="o">=</span><span class="n">polytomy_size_limit</span><span class="p">,</span>
                                                       <span class="n">skip_large_polytomies</span><span class="o">=</span><span class="n">skip_large_polytomies</span><span class="p">)]</span>
            <span class="n">attr_t1</span><span class="p">,</span> <span class="n">attr_t2</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_trees</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref_t</span><span class="p">]</span>
            <span class="n">target_trees</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_t</span><span class="p">]</span>

        <span class="n">polytomy_correction</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">correct_by_polytomy_size</span><span class="p">:</span>
            <span class="n">corr1</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ref_t</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">corr2</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">target_t</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">corr1</span> <span class="ow">and</span> <span class="n">corr2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Both trees contain polytomies! Try expand_polytomies=True instead&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">polytomy_correction</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">corr1</span><span class="p">,</span> <span class="n">corr2</span><span class="p">])</span>

        <span class="n">min_comparison</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">t1</span> <span class="ow">in</span> <span class="n">ref_trees</span><span class="p">:</span>
            <span class="n">t1_content</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">()</span>
            <span class="n">t1_leaves</span> <span class="o">=</span> <span class="n">t1_content</span><span class="p">[</span><span class="n">t1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">unrooted_trees</span><span class="p">:</span>
                <span class="n">edges1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
                        <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">content</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">])),</span>
                                      <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t1_leaves</span><span class="o">-</span><span class="n">content</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">]))]))</span>
                        <span class="k">for</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">t1_content</span><span class="p">)])</span>
                <span class="n">edges1</span><span class="o">.</span><span class="n">discard</span><span class="p">(((),()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
                        <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">content</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">]))</span>
                        <span class="k">for</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">t1_content</span><span class="p">)])</span>
                <span class="n">edges1</span><span class="o">.</span><span class="n">discard</span><span class="p">(())</span>

            <span class="k">if</span> <span class="n">min_support_t1</span><span class="p">:</span>
                <span class="n">support_t1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span>
                        <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">content</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">])),</span> <span class="n">branch</span><span class="o">.</span><span class="n">support</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">branch</span><span class="p">,</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">t1_content</span><span class="p">)])</span>

            <span class="k">for</span> <span class="n">t2</span> <span class="ow">in</span> <span class="n">target_trees</span><span class="p">:</span>
                <span class="n">t2_content</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">()</span>
                <span class="n">t2_leaves</span> <span class="o">=</span> <span class="n">t2_content</span><span class="p">[</span><span class="n">t2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">unrooted_trees</span><span class="p">:</span>
                    <span class="n">edges2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
                            <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span>
                                        <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">content</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">])),</span>
                                        <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">t2_leaves</span><span class="o">-</span><span class="n">content</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">]))]))</span>
                            <span class="k">for</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">t2_content</span><span class="p">)])</span>
                    <span class="n">edges2</span><span class="o">.</span><span class="n">discard</span><span class="p">(((),()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edges2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span>
                            <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">content</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">]))</span>
                            <span class="k">for</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="n">t2_content</span><span class="p">)])</span>
                    <span class="n">edges2</span><span class="o">.</span><span class="n">discard</span><span class="p">(())</span>

                <span class="k">if</span> <span class="n">min_support_t2</span><span class="p">:</span>
                    <span class="n">support_t2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span>
                        <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">content</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">common_attrs</span><span class="p">]))),</span> <span class="n">branch</span><span class="o">.</span><span class="n">support</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">branch</span><span class="p">,</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">t2_content</span><span class="p">)])</span>


                <span class="c1"># if a support value is passed as a constraint, discard lowly supported branches from the analysis</span>
                <span class="n">discard_t1</span><span class="p">,</span> <span class="n">discard_t2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">min_support_t1</span> <span class="ow">and</span> <span class="n">unrooted_trees</span><span class="p">:</span>
                    <span class="n">discard_t1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">edges1</span> <span class="k">if</span> <span class="n">support_t1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">support_t1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">999999999</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_support_t1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">min_support_t1</span><span class="p">:</span>
                    <span class="n">discard_t1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">edges1</span> <span class="k">if</span> <span class="n">support_t1</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_support_t1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">min_support_t2</span> <span class="ow">and</span> <span class="n">unrooted_trees</span><span class="p">:</span>
                    <span class="n">discard_t2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">edges2</span> <span class="k">if</span> <span class="n">support_t2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">support_t2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">999999999</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_support_t2</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">min_support_t2</span><span class="p">:</span>
                    <span class="n">discard_t2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">edges2</span> <span class="k">if</span> <span class="n">support_t2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_support_t2</span><span class="p">])</span>


                <span class="c1">#rf = len(edges1 ^ edges2) - (len(discard_t1) + len(discard_t2)) - polytomy_correction # poly_corr is 0 if the flag is not enabled</span>
                <span class="c1">#rf = len((edges1-discard_t1) ^ (edges2-discard_t2)) - polytomy_correction</span>

                <span class="c1"># the two root edges are never counted here, as they are always</span>
                <span class="c1"># present in both trees because of the common attr filters</span>
                <span class="n">rf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(((</span><span class="n">edges1</span> <span class="o">^</span> <span class="n">edges2</span><span class="p">)</span> <span class="o">-</span> <span class="n">discard_t2</span><span class="p">)</span> <span class="o">-</span> <span class="n">discard_t1</span><span class="p">)</span> <span class="o">-</span> <span class="n">polytomy_correction</span>

                <span class="k">if</span> <span class="n">unrooted_trees</span><span class="p">:</span>
                    <span class="c1"># thought this may work, but it does not, still I don&#39;t see why</span>
                    <span class="c1">#max_parts = (len(common_attrs)*2) - 6 - len(discard_t1) - len(discard_t2)</span>
                    <span class="n">max_parts</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">edges1</span> <span class="o">-</span> <span class="n">discard_t1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                                 <span class="nb">len</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">edges2</span> <span class="o">-</span> <span class="n">discard_t2</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># thought this may work, but it does not, still I don&#39;t see why</span>
                    <span class="c1">#max_parts = (len(common_attrs)*2) - 4 - len(discard_t1) - len(discard_t2)</span>

                    <span class="c1"># Otherwise we need to count the actual number of valid</span>
                    <span class="c1"># partitions in each tree -2 is to avoid counting the root</span>
                    <span class="c1"># partition of the two trees (only needed in rooted trees)</span>
                    <span class="n">max_parts</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">edges1</span> <span class="o">-</span> <span class="n">discard_t1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                                 <span class="nb">len</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">edges2</span> <span class="o">-</span> <span class="n">discard_t2</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">2</span>

                    <span class="c1"># print max_parts</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">min_comparison</span> <span class="ow">or</span> <span class="n">min_comparison</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rf</span><span class="p">:</span>
                    <span class="n">min_comparison</span> <span class="o">=</span> <span class="p">[</span><span class="n">rf</span><span class="p">,</span> <span class="n">max_parts</span><span class="p">,</span> <span class="n">common_attrs</span><span class="p">,</span> <span class="n">edges1</span><span class="p">,</span> <span class="n">edges2</span><span class="p">,</span> <span class="n">discard_t1</span><span class="p">,</span> <span class="n">discard_t2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">min_comparison</span></div>



<div class="viewcode-block" id="TreeNode.compare"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.compare">[docs]</a>    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_tree</span><span class="p">,</span> <span class="n">use_collateral</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">min_support_source</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">min_support_ref</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="n">has_duplications</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">expand_polytomies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unrooted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">max_treeko_splits_to_be_artifact</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">ref_tree_attr</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">source_tree_attr</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;compare this tree with another using robinson foulds symmetric difference</span>
<span class="sd">        and number of shared edges. Trees of different sizes and with duplicated</span>
<span class="sd">        items allowed.</span>

<span class="sd">        returns: a Python dictionary with results</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source_tree</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">def</span> <span class="nf">_safe_div</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="mf">0.0</span>

        <span class="k">def</span> <span class="nf">_compare</span><span class="p">(</span><span class="n">src_tree</span><span class="p">,</span> <span class="n">ref_tree</span><span class="p">):</span>
            <span class="c1"># calculate partitions and rf distances</span>
            <span class="n">rf</span><span class="p">,</span> <span class="n">maxrf</span><span class="p">,</span> <span class="n">common</span><span class="p">,</span> <span class="n">ref_p</span><span class="p">,</span> <span class="n">src_p</span><span class="p">,</span> <span class="n">ref_disc</span><span class="p">,</span> <span class="n">src_disc</span>  <span class="o">=</span> <span class="n">ref_tree</span><span class="o">.</span><span class="n">robinson_foulds</span><span class="p">(</span><span class="n">src_tree</span><span class="p">,</span>
                                                                                            <span class="n">expand_polytomies</span><span class="o">=</span><span class="n">expand_polytomies</span><span class="p">,</span>
                                                                                            <span class="n">unrooted_trees</span><span class="o">=</span><span class="n">unrooted</span><span class="p">,</span>
                                                                                            <span class="n">attr_t1</span><span class="o">=</span><span class="n">ref_tree_attr</span><span class="p">,</span>
                                                                                            <span class="n">attr_t2</span><span class="o">=</span><span class="n">source_tree_attr</span><span class="p">,</span>
                                                                                            <span class="n">min_support_t2</span><span class="o">=</span><span class="n">min_support_source</span><span class="p">,</span>
                                                                                            <span class="n">min_support_t1</span><span class="o">=</span><span class="n">min_support_ref</span><span class="p">)</span>

            <span class="c1"># if trees share leaves, count their distances</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">src_p</span> <span class="ow">and</span> <span class="n">ref_p</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">unrooted</span><span class="p">:</span>
                    <span class="n">valid_ref_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ref_p</span> <span class="o">-</span> <span class="n">ref_disc</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">valid_src_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">(</span><span class="n">src_p</span> <span class="o">-</span> <span class="n">src_disc</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">common_edges</span> <span class="o">=</span> <span class="n">valid_ref_edges</span> <span class="o">&amp;</span> <span class="n">valid_src_edges</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="n">valid_ref_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ref_p</span> <span class="o">-</span> <span class="n">ref_disc</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">valid_src_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">(</span><span class="n">src_p</span> <span class="o">-</span> <span class="n">src_disc</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">common_edges</span> <span class="o">=</span> <span class="n">valid_ref_edges</span> <span class="o">&amp;</span> <span class="n">valid_src_edges</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">valid_ref_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">valid_src_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">common_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

                <span class="c1"># # % of ref edges found in tree</span>
                <span class="c1"># ref_found.append(float(len(p2 &amp; p1)) / reftree_edges)</span>

                <span class="c1"># # valid edges in target, discard also leaves</span>
                <span class="c1"># p2bis = set([p for p in (p2-d2) if len(p[0])&gt;1 and len(p[1])&gt;1])</span>
                <span class="c1"># if p2bis:</span>
                <span class="c1">#     incompatible_target_branches = float(len((p2-d2) - p1))</span>
                <span class="c1">#     target_found.append(1 - (incompatible_target_branches / (len(p2-d2))))</span>

            <span class="k">return</span> <span class="n">rf</span><span class="p">,</span> <span class="n">maxrf</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">),</span> <span class="n">valid_ref_edges</span><span class="p">,</span> <span class="n">valid_src_edges</span><span class="p">,</span> <span class="n">common_edges</span>


        <span class="n">total_valid_ref_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ref_tree</span><span class="o">.</span><span class="n">traverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">support</span> <span class="o">&gt;</span> <span class="n">min_support_ref</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">has_duplications</span><span class="p">:</span>
            <span class="n">orig_target_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_tree</span><span class="p">)</span>
            <span class="n">ntrees</span><span class="p">,</span> <span class="n">ndups</span><span class="p">,</span> <span class="n">sp_trees</span> <span class="o">=</span> <span class="n">source_tree</span><span class="o">.</span><span class="n">get_speciation_trees</span><span class="p">(</span>
                <span class="n">autodetect_duplications</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">newick_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">target_attr</span><span class="o">=</span><span class="n">source_tree_attr</span><span class="p">,</span> <span class="n">map_features</span><span class="o">=</span><span class="p">[</span><span class="n">source_tree_attr</span><span class="p">,</span> <span class="s2">&quot;support&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">ntrees</span> <span class="o">&lt;</span> <span class="n">max_treeko_splits_to_be_artifact</span><span class="p">:</span>
                <span class="n">all_rf</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ref_found</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">src_found</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">tree_sizes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">all_max_rf</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">common_names</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">subtree_nw</span> <span class="ow">in</span> <span class="n">sp_trees</span><span class="p">:</span>

                    <span class="c1">#if seedid and not use_collateral and (seedid not in subtree_nw):</span>
                    <span class="c1">#    continue</span>
                    <span class="n">subtree</span> <span class="o">=</span> <span class="n">source_tree</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">subtree_nw</span><span class="p">,</span> <span class="n">sp_naming_function</span> <span class="o">=</span> <span class="n">source_tree</span><span class="o">.</span><span class="n">_speciesFunction</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">subtree</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># only necessary if rf function is going to filter by support</span>
                    <span class="c1"># value.  It slows downs the analysis, obviously, as it has to</span>
                    <span class="c1"># find the support for each node in the treeko tree from the</span>
                    <span class="c1"># original one.</span>
                    <span class="k">if</span> <span class="n">min_support_source</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">subtree_content</span> <span class="o">=</span> <span class="n">subtree</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">(</span><span class="n">store_attr</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">subtree</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                                <span class="n">n</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">source_tree</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="n">subtree_content</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">support</span>

                    <span class="n">total_rf</span><span class="p">,</span> <span class="n">max_rf</span><span class="p">,</span> <span class="n">ncommon</span><span class="p">,</span> <span class="n">valid_ref_edges</span><span class="p">,</span> <span class="n">valid_src_edges</span><span class="p">,</span> <span class="n">common_edges</span> <span class="o">=</span> <span class="n">_compare</span><span class="p">(</span><span class="n">subtree</span><span class="p">,</span> <span class="n">ref_tree</span><span class="p">)</span>

                    <span class="n">all_rf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_rf</span><span class="p">)</span>
                    <span class="n">all_max_rf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_rf</span><span class="p">)</span>
                    <span class="n">tree_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ncommon</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">unrooted</span><span class="p">:</span>
                        <span class="n">ref_found_in_src</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_ref_edges</span><span class="p">))</span> <span class="k">if</span> <span class="n">valid_ref_edges</span> <span class="k">else</span> <span class="kc">None</span>
                        <span class="n">src_found_in_ref</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_src_edges</span><span class="p">))</span> <span class="k">if</span> <span class="n">valid_src_edges</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># in rooted trees, we want to discount the root edge</span>
                        <span class="c1"># from the percentage of congruence. Otherwise we will never see a 0%</span>
                        <span class="c1"># congruence for totally different trees</span>
                        <span class="n">ref_found_in_src</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_ref_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_ref_edges</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
                        <span class="n">src_found_in_ref</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_src_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_src_edges</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>

                    <span class="k">if</span> <span class="n">ref_found_in_src</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ref_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_found_in_src</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">src_found_in_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">src_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src_found_in_ref</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">all_rf</span><span class="p">:</span>
                    <span class="c1"># Treeko speciation distance</span>
                    <span class="n">alld</span> <span class="o">=</span> <span class="p">[</span><span class="n">_safe_div</span><span class="p">(</span><span class="n">all_rf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">all_max_rf</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_rf</span><span class="p">))]</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">alld</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">tree_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_rf</span><span class="p">))])</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">tree_sizes</span><span class="p">))</span>
                    <span class="n">treeko_d</span> <span class="o">=</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span> <span class="k">if</span> <span class="n">a</span> <span class="k">else</span> <span class="mf">0.0</span>
                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;treeko_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">treeko_d</span>

                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;rf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">all_rf</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;max_rf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">all_max_rf</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;effective_tree_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tree_sizes</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;norm_rf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">_safe_div</span><span class="p">(</span><span class="n">all_rf</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">all_max_rf</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_rf</span><span class="p">))])</span>

                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ref_edges_in_source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ref_found</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source_edges_in_ref&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">src_found</span><span class="p">)</span>

                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source_subtrees&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_rf</span><span class="p">)</span>
                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;common_edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source_edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ref_edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_rf</span><span class="p">,</span> <span class="n">max_rf</span><span class="p">,</span> <span class="n">ncommon</span><span class="p">,</span> <span class="n">valid_ref_edges</span><span class="p">,</span> <span class="n">valid_src_edges</span><span class="p">,</span> <span class="n">common_edges</span> <span class="o">=</span> <span class="n">_compare</span><span class="p">(</span><span class="n">source_tree</span><span class="p">,</span> <span class="n">ref_tree</span><span class="p">)</span>

            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;rf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">total_rf</span><span class="p">)</span> <span class="k">if</span> <span class="n">max_rf</span> <span class="k">else</span> <span class="s2">&quot;NA&quot;</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;max_rf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">max_rf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unrooted</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ref_edges_in_source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_ref_edges</span><span class="p">))</span> <span class="k">if</span> <span class="n">valid_ref_edges</span> <span class="k">else</span> <span class="s2">&quot;NA&quot;</span>
                <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source_edges_in_ref&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_src_edges</span><span class="p">))</span> <span class="k">if</span> <span class="n">valid_src_edges</span> <span class="k">else</span> <span class="s2">&quot;NA&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># in rooted trees, we want to discount the root edge from the</span>
                <span class="c1"># percentage of congruence. Otherwise we will never see a 0%</span>
                <span class="c1"># congruence for totally different trees</span>
                <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ref_edges_in_source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_ref_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_ref_edges</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;NA&quot;</span>
                <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source_edges_in_ref&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">valid_src_edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_src_edges</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;NA&quot;</span>

            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;effective_tree_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ncommon</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;norm_rf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rf</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">max_rf</span><span class="p">)</span> <span class="k">if</span> <span class="n">max_rf</span> <span class="k">else</span> <span class="s2">&quot;NA&quot;</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;treeko_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;NA&quot;</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source_subtrees&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;common_edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">common_edges</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;source_edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_src_edges</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;ref_edges&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_ref_edges</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;topology&#39;</span><span class="p">,</span> <span class="n">attr_t1</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">attr_t2</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 2.3</span>

<span class="sd">        Show or return the difference between two tree topologies.</span>

<span class="sd">        :param [raw|table|topology|diffs|diffs_tab] output: Output type</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..tools</span> <span class="kn">import</span> <span class="n">ete_diff</span>
        <span class="n">difftable</span> <span class="o">=</span> <span class="n">ete_diff</span><span class="o">.</span><span class="n">treediff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">attr1</span><span class="o">=</span><span class="n">attr_t1</span><span class="p">,</span> <span class="n">attr2</span><span class="o">=</span><span class="n">attr_t2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s2">&quot;topology&quot;</span><span class="p">:</span>
            <span class="n">ete_diff</span><span class="o">.</span><span class="n">show_difftable_topo</span><span class="p">(</span><span class="n">difftable</span><span class="p">,</span> <span class="n">attr_t1</span><span class="p">,</span> <span class="n">attr_t2</span><span class="p">,</span> <span class="n">usecolor</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">output</span> <span class="o">==</span> <span class="s2">&quot;diffs&quot;</span><span class="p">:</span>
            <span class="n">ete_diff</span><span class="o">.</span><span class="n">show_difftable</span><span class="p">(</span><span class="n">difftable</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">output</span> <span class="o">==</span> <span class="s2">&quot;diffs_tab&quot;</span><span class="p">:</span>
            <span class="n">ete_diff</span><span class="o">.</span><span class="n">show_difftable_tab</span><span class="p">(</span><span class="n">difftable</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;table&#39;</span><span class="p">:</span>
            <span class="n">rf</span><span class="p">,</span> <span class="n">rf_max</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">robinson_foulds</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">attr_t1</span><span class="o">=</span><span class="n">attr_t1</span><span class="p">,</span> <span class="n">attr_t2</span><span class="o">=</span><span class="n">attr_t2</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">ete_diff</span><span class="o">.</span><span class="n">show_difftable_summary</span><span class="p">(</span><span class="n">difftable</span><span class="p">,</span> <span class="n">rf</span><span class="p">,</span> <span class="n">rf_max</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">difftable</span>

<div class="viewcode-block" id="TreeNode.iter_edges"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.iter_edges">[docs]</a>    <span class="k">def</span> <span class="nf">iter_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cached_content</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. versionadded:: 2.3</span>

<span class="sd">        Iterate over the list of edges of a tree. Each edge is represented as a</span>
<span class="sd">        tuple of two elements, each containing the list of nodes separated by</span>
<span class="sd">        the edge.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">cached_content</span><span class="p">:</span>
            <span class="n">cached_content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">()</span>
        <span class="n">all_leaves</span> <span class="o">=</span> <span class="n">cached_content</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">side1</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">cached_content</span><span class="p">):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">side1</span><span class="p">,</span> <span class="n">all_leaves</span><span class="o">-</span><span class="n">side1</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.get_edges"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cached_content</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. versionadded:: 2.3</span>

<span class="sd">        Returns the list of edges of a tree. Each edge is represented as a</span>
<span class="sd">        tuple of two elements, each containing the list of nodes separated by</span>
<span class="sd">        the edge.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">edge</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_edges</span><span class="p">(</span><span class="n">cached_content</span><span class="p">)]</span></div>

<div class="viewcode-block" id="TreeNode.standardize"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.standardize">[docs]</a>    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delete_orphan</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">preserve_branch_length</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 2.3</span>

<span class="sd">        process current tree structure to produce a standardized topology: nodes</span>
<span class="sd">        with only one child are removed and multifurcations are automatically resolved.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolve_polytomy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_descendants</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">n</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">prevent_nondicotomic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">preserve_branch_length</span><span class="o">=</span><span class="n">preserve_branch_length</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeNode.get_topology_id"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_topology_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_topology_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. versionadded:: 2.3</span>

<span class="sd">        Returns the unique ID representing the topology of the current tree. Two</span>
<span class="sd">        trees with the same topology will produce the same id. If trees are</span>
<span class="sd">        unrooted, make sure that the root node is not binary or use the</span>
<span class="sd">        tree.unroot() function before generating the topology id.</span>

<span class="sd">        This is useful to detect the number of unique topologies over a bunch of</span>
<span class="sd">        trees, without requiring full distance methods.</span>

<span class="sd">        The id is, by default, calculated based on the terminal node&#39;s names. Any</span>
<span class="sd">        other node attribute could be used instead.</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">edge_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">():</span>
            <span class="n">k1</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">s1</span><span class="p">])</span>
            <span class="n">k2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">s2</span><span class="p">])</span>
            <span class="n">edge_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">edge_keys</span><span class="p">))</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span></div>

    <span class="c1"># def get_partitions(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     .. versionadded: 2.1</span>

    <span class="c1">#     It returns the set of all possible partitions under a</span>
    <span class="c1">#     node. Note that current implementation is quite inefficient</span>
    <span class="c1">#     when used in very large trees.</span>

    <span class="c1">#     t = Tree(&quot;((a, b), e);&quot;)</span>
    <span class="c1">#     partitions = t.get_partitions()</span>

    <span class="c1">#     # Will return:</span>
    <span class="c1">#     # a,b,e</span>
    <span class="c1">#     # a,e</span>
    <span class="c1">#     # b,e</span>
    <span class="c1">#     # a,b</span>
    <span class="c1">#     # e</span>
    <span class="c1">#     # b</span>
    <span class="c1">#     # a</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     all_leaves = frozenset(self.get_leaf_names())</span>
    <span class="c1">#     all_partitions = set([all_leaves])</span>
    <span class="c1">#     for n in self.iter_descendants():</span>
    <span class="c1">#         p1 = frozenset(n.get_leaf_names())</span>
    <span class="c1">#         p2 = frozenset(all_leaves - p1)</span>
    <span class="c1">#         all_partitions.add(p1)</span>
    <span class="c1">#         all_partitions.add(p2)</span>
    <span class="c1">#     return all_partitions</span>

<div class="viewcode-block" id="TreeNode.convert_to_ultrametric"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.convert_to_ultrametric">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_ultrametric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded: 2.1</span>

<span class="sd">        Converts a tree into ultrametric topology (all leaves must have</span>
<span class="sd">        the same distance to root). Note that, for visual inspection</span>
<span class="sd">        of ultrametric trees, node.img_style[&quot;size&quot;] should be set to</span>
<span class="sd">        0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Could something like this replace the old algorithm?</span>
        <span class="c1">#most_distant_leaf, tree_length = self.get_farthest_leaf()</span>
        <span class="c1">#for leaf in self:</span>
        <span class="c1">#    d = leaf.get_distance(self)</span>
        <span class="c1">#    leaf.dist += (tree_length - d)</span>
        <span class="c1">#return</span>



        <span class="c1"># pre-calculate how many splits remain under each node</span>
        <span class="n">node2max_depth</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="s2">&quot;postorder&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">max_depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">node2max_depth</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">node2max_depth</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_depth</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node2max_depth</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">node2dist</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tree_length</span><span class="p">:</span>
            <span class="n">most_distant_leaf</span><span class="p">,</span> <span class="n">tree_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_farthest_leaf</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tree_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tree_length</span><span class="p">)</span>


        <span class="n">step</span> <span class="o">=</span> <span class="n">tree_length</span> <span class="o">/</span> <span class="n">node2max_depth</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_descendants</span><span class="p">(</span><span class="s2">&quot;levelorder&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;balanced&quot;</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">tree_length</span> <span class="o">-</span> <span class="n">node2dist</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">up</span><span class="p">])</span> <span class="o">/</span> <span class="n">node2max_depth</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
                <span class="n">node2dist</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span>  <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">+</span> <span class="n">node2dist</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">up</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">step</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">tree_length</span> <span class="o">-</span> <span class="p">((</span><span class="n">node2dist</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">up</span><span class="p">])</span> <span class="o">*</span> <span class="n">step</span><span class="p">)</span>
                <span class="n">node2dist</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">node2dist</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span></div>

<div class="viewcode-block" id="TreeNode.check_monophyly"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.check_monophyly">[docs]</a>    <span class="k">def</span> <span class="nf">check_monophyly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">target_attr</span><span class="p">,</span> <span class="n">ignore_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">unrooted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded: 2.2</span>

<span class="sd">        Returns True if a given target attribute is monophyletic under</span>
<span class="sd">        this node for the provided set of values.</span>

<span class="sd">        If not all values are represented in the current tree</span>
<span class="sd">        structure, a ValueError exception will be raised to warn that</span>
<span class="sd">        strict monophyly could never be reached (this behaviour can be</span>
<span class="sd">        avoided by enabling the `ignore_missing` flag.</span>

<span class="sd">        :param values: a set of values for which monophyly is</span>
<span class="sd">            expected.</span>

<span class="sd">        :param target_attr: node attribute being used to check</span>
<span class="sd">            monophyly (i.e. species for species trees, names for gene</span>
<span class="sd">            family trees, or any custom feature present in the tree).</span>

<span class="sd">        :param False ignore_missing: Avoid raising an Exception when</span>
<span class="sd">            missing attributes are found.</span>


<span class="sd">        .. versionchanged: 2.3</span>

<span class="sd">        :param False unrooted: If True, tree will be treated as unrooted, thus</span>
<span class="sd">          allowing to find monophyly even when current outgroup is splitting a</span>
<span class="sd">          monophyletic group.</span>

<span class="sd">        :returns: the following tuple</span>
<span class="sd">                  IsMonophyletic (boolean),</span>
<span class="sd">                  clade type (&#39;monophyletic&#39;, &#39;paraphyletic&#39; or &#39;polyphyletic&#39;),</span>
<span class="sd">                  leaves breaking the monophyly (set)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># This is the only time I traverse the tree, then I use cached</span>
        <span class="c1"># leaf content</span>
        <span class="n">n2leaves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">()</span>

        <span class="c1"># Raise an error if requested attribute values are not even present</span>
        <span class="k">if</span> <span class="n">ignore_missing</span><span class="p">:</span>
            <span class="n">found_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">target_attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">n2leaves</span><span class="p">[</span><span class="bp">self</span><span class="p">]])</span>
            <span class="n">missing_values</span> <span class="o">=</span> <span class="n">values</span> <span class="o">-</span> <span class="n">found_values</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span> <span class="o">&amp;</span> <span class="n">found_values</span>

        <span class="c1"># Locate leaves matching requested attribute values</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">n2leaves</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
                   <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">target_attr</span><span class="p">)</span> <span class="ow">in</span> <span class="n">values</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_missing</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">values</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="nb">getattr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">target_attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The monophyly of the provided values could never be reached, as not all of them exist in the tree.&#39;</span>
                                 <span class="s1">&#39; Please check your target attribute and values, or set the ignore_missing flag to True&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unrooted</span><span class="p">:</span>
            <span class="n">smallest</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">side1</span><span class="p">,</span> <span class="n">side2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_edges</span><span class="p">(</span><span class="n">cached_content</span><span class="o">=</span><span class="n">n2leaves</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">targets</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">side1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">smallest</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">side1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">smallest</span><span class="p">)):</span>
                    <span class="n">smallest</span> <span class="o">=</span> <span class="n">side1</span>
                <span class="k">elif</span> <span class="n">targets</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">side2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">smallest</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">side2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">smallest</span><span class="p">)):</span>
                        <span class="n">smallest</span> <span class="o">=</span> <span class="n">side2</span>
                <span class="k">if</span> <span class="n">smallest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">smallest</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="n">foreign_leaves</span> <span class="o">=</span> <span class="n">smallest</span> <span class="o">-</span> <span class="n">targets</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check monophyly with get_common_ancestor. Note that this</span>
            <span class="c1"># step does not require traversing the tree again because</span>
            <span class="c1"># targets are node instances instead of node names, and</span>
            <span class="c1"># get_common_ancestor function is smart enough to detect it</span>
            <span class="c1"># and avoid unnecessary traversing.</span>
            <span class="n">common</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="n">targets</span><span class="p">)</span>
            <span class="n">observed</span> <span class="o">=</span> <span class="n">n2leaves</span><span class="p">[</span><span class="n">common</span><span class="p">]</span>
            <span class="n">foreign_leaves</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">observed</span>
                              <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">target_attr</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">values</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">foreign_leaves</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;monophyletic&quot;</span><span class="p">,</span> <span class="n">foreign_leaves</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if the requested attribute is not monophyletic in this</span>
            <span class="c1"># node, let&#39;s differentiate between poly and paraphyly.</span>
            <span class="n">poly_common</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_common_ancestor</span><span class="p">(</span><span class="n">foreign_leaves</span><span class="p">)</span>
            <span class="c1"># if the common ancestor of all foreign leaves is self</span>
            <span class="c1"># contained, we have a paraphyly. Otherwise, polyphyly.</span>
            <span class="n">polyphyletic</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">poly_common</span> <span class="k">if</span>
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">target_attr</span><span class="p">)</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">polyphyletic</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;polyphyletic&quot;</span><span class="p">,</span> <span class="n">foreign_leaves</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;paraphyletic&quot;</span><span class="p">,</span> <span class="n">foreign_leaves</span></div>

<div class="viewcode-block" id="TreeNode.get_monophyletic"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.get_monophyletic">[docs]</a>    <span class="k">def</span> <span class="nf">get_monophyletic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">target_attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 2.2</span>

<span class="sd">        Returns a list of nodes matching the provided monophyly</span>
<span class="sd">        criteria. For a node to be considered a match, all</span>
<span class="sd">        `target_attr` values within and node, and exclusively them,</span>
<span class="sd">        should be grouped.</span>

<span class="sd">        :param values: a set of values for which monophyly is</span>
<span class="sd">            expected.</span>

<span class="sd">        :param target_attr: node attribute being used to check</span>
<span class="sd">            monophyly (i.e. species for species trees, names for gene</span>
<span class="sd">            family trees).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">n2values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cached_content</span><span class="p">(</span><span class="n">store_attr</span><span class="o">=</span><span class="n">target_attr</span><span class="p">)</span>

        <span class="n">is_monophyletic</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">n2values</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">values</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_leaves</span><span class="p">(</span><span class="n">is_leaf_fn</span><span class="o">=</span><span class="n">is_monophyletic</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_monophyletic</span><span class="p">(</span><span class="n">match</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">match</span></div>

<div class="viewcode-block" id="TreeNode.expand_polytomies"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.expand_polytomies">[docs]</a>    <span class="k">def</span> <span class="nf">expand_polytomies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_attr</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">polytomy_size_limit</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                          <span class="n">skip_large_polytomies</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        .. versionadded:: 2.3</span>

<span class="sd">        Given a tree with one or more polytomies, this functions returns the</span>
<span class="sd">        list of all trees (in newick format) resulting from the combination of</span>
<span class="sd">        all possible solutions of the multifurcated nodes.</span>

<span class="sd">        .. warning:</span>

<span class="sd">           Please note that the number of of possible binary trees grows</span>
<span class="sd">           exponentially with the number and size of polytomies. Using this</span>
<span class="sd">           function with large multifurcations is not feasible:</span>

<span class="sd">           polytomy size: 3 number of binary trees: 3</span>
<span class="sd">           polytomy size: 4 number of binary trees: 15</span>
<span class="sd">           polytomy size: 5 number of binary trees: 105</span>
<span class="sd">           polytomy size: 6 number of binary trees: 945</span>
<span class="sd">           polytomy size: 7 number of binary trees: 10395</span>
<span class="sd">           polytomy size: 8 number of binary trees: 135135</span>
<span class="sd">           polytomy size: 9 number of binary trees: 2027025</span>

<span class="sd">        http://ajmonline.org/2010/darwin.php</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">class</span> <span class="nc">TipTuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">add_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
          <span class="k">yield</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">TipTuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">left</span> <span class="ow">in</span> <span class="n">add_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="p">):</span>
              <span class="k">yield</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">add_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="p">):</span>
              <span class="k">yield</span> <span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">enum_unordered</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">enum_unordered</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
              <span class="k">for</span> <span class="n">new_tree</span> <span class="ow">in</span> <span class="n">add_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">yield</span> <span class="n">new_tree</span>

        <span class="n">n2subtrees</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="s2">&quot;postorder&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
                <span class="n">subtrees</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">map_attr</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subtrees</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">polytomy_size_limit</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">skip_large_polytomies</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">childtrees</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">n2subtrees</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">]):</span>
                            <span class="n">subtrees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TipTuple</span><span class="p">(</span><span class="n">childtrees</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Found polytomy larger than current limit: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">n</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">childtrees</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">n2subtrees</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="p">]):</span>
                        <span class="n">subtrees</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">TipTuple</span><span class="p">(</span><span class="n">subtree</span><span class="p">)</span> <span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">enum_unordered</span><span class="p">(</span><span class="n">childtrees</span><span class="p">)])</span>

            <span class="n">n2subtrees</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">subtrees</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">;&quot;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span> <span class="k">for</span> <span class="n">nw</span> <span class="ow">in</span> <span class="n">n2subtrees</span><span class="p">[</span><span class="bp">self</span><span class="p">]]</span> <span class="c1"># tuples are in newick format ^_^</span></div>

<div class="viewcode-block" id="TreeNode.resolve_polytomy"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.resolve_polytomy">[docs]</a>    <span class="k">def</span> <span class="nf">resolve_polytomy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_dist</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">default_support</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                         <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded: 2.2</span>

<span class="sd">        Resolve all polytomies under current node by creating an</span>
<span class="sd">        arbitrary dicotomic structure among the affected nodes. This</span>
<span class="sd">        function randomly modifies current tree topology and should</span>
<span class="sd">        only be used for compatibility reasons (i.e. programs</span>
<span class="sd">        rejecting multifurcated node in the newick representation).</span>

<span class="sd">        :param 0.0 default_dist: artificial branch distance of new</span>
<span class="sd">            nodes.</span>

<span class="sd">        :param 0.0 default_support: artificial branch support of new</span>
<span class="sd">            nodes.</span>

<span class="sd">        :param True recursive: Resolve any polytomy under this</span>
<span class="sd">             node. When False, only current node will be checked and fixed.</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">def</span> <span class="nf">_resolve</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
                <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">next_node</span> <span class="o">=</span> <span class="n">root</span> <span class="o">=</span> <span class="n">node</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">next_node</span> <span class="o">=</span> <span class="n">next_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">()</span>
                    <span class="n">next_node</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">default_dist</span>
                    <span class="n">next_node</span><span class="o">.</span><span class="n">support</span> <span class="o">=</span> <span class="n">default_support</span>

                <span class="n">next_node</span> <span class="o">=</span> <span class="n">root</span>
                <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                    <span class="n">next_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ch</span> <span class="o">!=</span> <span class="n">children</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">next_node</span> <span class="o">=</span> <span class="n">next_node</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="n">target</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_descendants</span><span class="p">()])</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">_resolve</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.cophenetic_matrix"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.cophenetic_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">cophenetic_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded: 3.1.1</span>

<span class="sd">        Generate a cophenetic distance matrix of the treee to standard output</span>

<span class="sd">        The `cophenetic matrix &lt;https://en.wikipedia.org/wiki/Cophenetic&gt;` is a matrix representation of the</span>
<span class="sd">        distance between each node.</span>

<span class="sd">        if we have a tree like</span>

<span class="sd">                                   ----A</span>
<span class="sd">                      _____________|y</span>
<span class="sd">                      |            |</span>
<span class="sd">                      |            ----B</span>
<span class="sd">              ________|z</span>
<span class="sd">                      |            ----C</span>
<span class="sd">                      |            |</span>
<span class="sd">                      |____________|x     -----D</span>
<span class="sd">                                   |      |</span>
<span class="sd">                                   |______|w</span>
<span class="sd">                                          |</span>
<span class="sd">                                          |</span>
<span class="sd">                                          -----E</span>

<span class="sd">        Where w,x,y,z are internal nodes.</span>
<span class="sd">        d(A,B) = d(y,A) + d(y,B)</span>
<span class="sd">        and</span>
<span class="sd">        d(A, E) = d(z,A) + d(z, E) = {d(z,y) + d(y,A)} + {d(z,x) + d(x,w) + d(w,E)}</span>

<span class="sd">        We use an idea inspired by the ete3 team: https://gist.github.com/jhcepas/279f9009f46bf675e3a890c19191158b :</span>

<span class="sd">        For each node find its path to the root.</span>

<span class="sd">        e.g.</span>

<span class="sd">        A -&gt; A, y, z</span>
<span class="sd">        E -&gt; E, w, x,z</span>

<span class="sd">        and make these orderless sets. Then we XOR the two sets to only find the elements</span>
<span class="sd">        that are in one or other sets but not both. In this case A, E, y, x, w.</span>

<span class="sd">        The distance between the two nodes is the sum of the distances from each of those nodes</span>
<span class="sd">        to the parent</span>

<span class="sd">        One more optimization: since the distances are symmetric, and distance to itself is zero</span>
<span class="sd">        we user itertools.combinations rather than itertools.permutations. This cuts our computes from theta(n^2)</span>
<span class="sd">        1/2n^2 - n (= O(n^2), which is still not great, but in reality speeds things up for large trees).</span>


<span class="sd">        For this tree, we will return the two dimensional array:</span>
<span class="sd">                         A                  B                   C                   D                     E</span>
<span class="sd">        A                0           d(A-y) + d(B-y)     d(A-z) + d(C-z)     d(A-z) + d(D-z)       d(A-z) + d(E-z)</span>
<span class="sd">        B         d(B-y) + d(A-y)           0            d(B-z) + d(C-z)     d(B-z) + d(D-z)       d(B-z) + d(E-z)</span>
<span class="sd">        C         d(C-z) + d(A-z)    d(C-z) + d(B-z)            0            d(C-x) + d(D-x)       d(C-x) + d(E-x)</span>
<span class="sd">        D         d(D-z) + d(A-z)    d(D-z) + d(B-z)     d(D-x) + d(C-x)            0              d(D-w) + d(E-w)</span>
<span class="sd">        E         d(E-z) + d(A-z)    d(E-z) + d(B-z)     d(E-x) + d(C-x)     d(E-w) + d(D-w)              0</span>

<span class="sd">        We will also return the one dimensional array with the leaves in the order in which they appear in the matrix</span>
<span class="sd">        (i.e. the column and/or row headers).</span>

<span class="sd">        :param filename: the optional file to write to. If not provided, output will be to standard output</span>
<span class="sd">        :return: two-dimensional array and a one dimensional array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">leaves</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_leaves</span><span class="p">()</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">}</span>

        <span class="c1"># get the paths going up the tree</span>
        <span class="c1"># we get all the nodes up to the last one and store them in a set</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
                <span class="k">continue</span>
            <span class="n">movingnode</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">movingnode</span><span class="o">.</span><span class="n">is_root</span><span class="p">():</span>
                <span class="n">paths</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">movingnode</span><span class="p">)</span>
                <span class="n">movingnode</span> <span class="o">=</span> <span class="n">movingnode</span><span class="o">.</span><span class="n">up</span>

        <span class="c1"># now we want to get all pairs of nodes using itertools combinations. We need AB AC etc but don&#39;t need BA CA</span>

        <span class="n">leaf_distances</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">leaf1</span><span class="p">,</span> <span class="n">leaf2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">leaves</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="c1"># figure out the unique nodes in the path</span>
            <span class="n">uniquenodes</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">leaf1</span><span class="p">]</span> <span class="o">^</span> <span class="n">paths</span><span class="p">[</span><span class="n">leaf2</span><span class="p">]</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dist</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">uniquenodes</span><span class="p">)</span>
            <span class="n">leaf_distances</span><span class="p">[</span><span class="n">leaf1</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="n">leaf2</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf_distances</span><span class="p">[</span><span class="n">leaf2</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="n">leaf1</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>

        <span class="n">allleaves</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">leaf_distances</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="c1"># the leaves in order that we will return</span>

        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># the two dimensional array that we will return</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">allleaves</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">allleaves</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># distance to ourself = 0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaf_distances</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">m</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">,</span> <span class="n">allleaves</span></div>

<div class="viewcode-block" id="TreeNode.add_face"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.add_face">[docs]</a>    <span class="k">def</span> <span class="nf">add_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s2">&quot;branch-right&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded: 2.1</span>

<span class="sd">        Add a fixed face to the node.  This type of faces will be</span>
<span class="sd">        always attached to nodes, independently of the layout</span>
<span class="sd">        function.</span>

<span class="sd">        :argument face: a Face or inherited instance</span>
<span class="sd">        :argument column: An integer number starting from 0</span>
<span class="sd">        :argument &quot;branch-right&quot; position: Posible values are:</span>
<span class="sd">          &quot;branch-right&quot;, &quot;branch-top&quot;, &quot;branch-bottom&quot;, &quot;float&quot;,</span>
<span class="sd">          &quot;aligned&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_faces&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_faces</span> <span class="o">=</span> <span class="n">_FaceAreas</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FACE_POSITIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;face position not in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">FACE_POSITIONS</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">Face</span><span class="p">):</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_faces</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span><span class="o">.</span><span class="n">add_face</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">column</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;not a Face instance&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.set_style"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.set_style">[docs]</a>    <span class="k">def</span> <span class="nf">set_style</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_style</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded: 2.1</span>

<span class="sd">        Set &#39;node_style&#39; as the fixed style for the current node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">TREEVIEW</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node_style</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node_style</span> <span class="o">=</span> <span class="n">NodeStyle</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">node_style</span><span class="p">)</span> <span class="ow">is</span> <span class="n">NodeStyle</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_img_style</span> <span class="o">=</span> <span class="n">node_style</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Treeview module is disabled&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeNode.from_parent_child_table"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.from_parent_child_table">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_parent_child_table</span><span class="p">(</span><span class="n">parent_child_table</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a parent-child table into an ETE Tree instance.</span>

<span class="sd">        :argument parent_child_table: a list of tuples containing parent-child</span>
<span class="sd">           relationships. For example: [(&quot;A&quot;, &quot;B&quot;, 0.1), (&quot;A&quot;, &quot;C&quot;, 0.2), (&quot;C&quot;,</span>
<span class="sd">           &quot;D&quot;, 1), (&quot;C&quot;, &quot;E&quot;, 1.5)]. Where each tuple represents: [parent, child,</span>
<span class="sd">           child-parent-dist]</span>

<span class="sd">        :returns: A new Tree instance</span>

<span class="sd">        :example:</span>

<span class="sd">        &gt;&gt;&gt; tree = Tree.from_parent_child_table([(&quot;A&quot;, &quot;B&quot;, 0.1), (&quot;A&quot;, &quot;C&quot;, 0.2), (&quot;C&quot;, &quot;D&quot;, 1), (&quot;C&quot;, &quot;E&quot;, 1.5)])</span>
<span class="sd">        &gt;&gt;&gt; print tree</span>

<span class="sd">        &quot;&quot;&quot;</span>


        <span class="k">def</span> <span class="nf">get_node</span><span class="p">(</span><span class="n">nodename</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nodename</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nodes_by_name</span><span class="p">:</span>
                <span class="n">nodes_by_name</span><span class="p">[</span><span class="n">nodename</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">nodename</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nodes_by_name</span><span class="p">[</span><span class="n">nodename</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span>
            <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">nodename</span>
            <span class="k">return</span> <span class="n">nodes_by_name</span><span class="p">[</span><span class="n">nodename</span><span class="p">]</span>

        <span class="n">nodes_by_name</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">columns</span> <span class="ow">in</span> <span class="n">parent_child_table</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">parent_name</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">columns</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent_name</span><span class="p">,</span> <span class="n">child_name</span> <span class="o">=</span> <span class="n">columns</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="n">parent_name</span><span class="p">)</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">get_node</span><span class="p">(</span><span class="n">child_name</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">))</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">root</span></div>

<div class="viewcode-block" id="TreeNode.from_skbio"><a class="viewcode-back" href="../../../_autosummary/gcdyn.bdms.TreeNode.html#gcdyn.bdms.TreeNode.from_skbio">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_skbio</span><span class="p">(</span><span class="n">skbio_tree</span><span class="p">,</span> <span class="n">map_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a scikit-bio TreeNode object into ETE Tree object.</span>

<span class="sd">        :argument skbio_tree: a scikit bio TreeNode instance</span>

<span class="sd">        :argument None map_attributes: A list of attribute nanes in the</span>
<span class="sd">           scikit-bio tree that should be mapped into the ETE tree</span>
<span class="sd">           instance. (name, id and branch length are always mapped)</span>

<span class="sd">        :returns: A new Tree instance</span>

<span class="sd">        :example:</span>

<span class="sd">        &gt;&gt;&gt; tree = Tree.from_skibio(skbioTree, map_attributes=[&quot;value&quot;])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">skbio</span> <span class="kn">import</span> <span class="n">TreeNode</span> <span class="k">as</span> <span class="n">skbioTreeNode</span>

        <span class="k">def</span> <span class="nf">get_ete_node</span><span class="p">(</span><span class="n">skbio_node</span><span class="p">):</span>
            <span class="n">ete_node</span> <span class="o">=</span> <span class="n">all_nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">skbio_node</span><span class="p">,</span> <span class="n">Tree</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">skbio_node</span><span class="o">.</span><span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ete_node</span><span class="o">.</span><span class="n">dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">skbio_node</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
            <span class="n">ete_node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">skbio_node</span><span class="o">.</span><span class="n">name</span>
            <span class="n">ete_node</span><span class="o">.</span><span class="n">add_features</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">skbio_node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">map_attributes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">map_attributes</span><span class="p">:</span>
                    <span class="n">ete_node</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">skbio_node</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">ete_node</span>

        <span class="n">all_nodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">skbio_tree</span><span class="p">,</span> <span class="n">skbioTreeNode</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">skbio_tree</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">include_self</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">all_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_ete_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">ete_node</span> <span class="o">=</span> <span class="n">all_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="n">ete_ch</span> <span class="o">=</span> <span class="n">get_ete_node</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                    <span class="n">ete_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">ete_ch</span><span class="p">)</span>
                    <span class="n">all_nodes</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">ete_ch</span>
            <span class="k">return</span> <span class="n">ete_ch</span><span class="o">.</span><span class="n">get_tree_root</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">phonehome</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">_ph</span>
        <span class="n">_ph</span><span class="o">.</span><span class="n">call</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_translate_nodes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes</span><span class="p">):</span>
    <span class="n">name2node</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">name2node</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">traverse</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">name2node</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name2node</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Ambiguous node name: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">name2node</span><span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>

    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">name2node</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">notfound</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">name2node</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node names not found: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">notfound</span><span class="p">))</span>

    <span class="n">valid_nodes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="vm">__class__</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="n">TreeError</span><span class="p">(</span><span class="s2">&quot;Invalid target node: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valid_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">valid_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">name2node</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_nodes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">valid_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">valid_nodes</span>

<span class="c1"># Alias</span>
<span class="c1">#: .. currentmodule:: ete3</span>
<span class="n">Tree</span> <span class="o">=</span> <span class="n">TreeNode</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Erick Matsen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>